\section{Potential Attacks}
\label{sec:security-vulnerable}

In this section, we describe two security vulnerabilities we discovered in our own implementation while writing this document. Both vulnerabilities exploit compromised friend, but are different from the CF attacks described in \cite{angel2018cf}. They illustrate the subtleties we have to overcome in our security proof.

\subsection{The PIR Replay Attack}
We first describe a vulnerability we call the PIR Replay Attack. While the CF attacks in \cite{angel2018cf} can only compromise the number of friends each honest user has, this vulnerability can potentially compromise the sender and recipient of every PIR request. Furthermore, the vulnerability is present in the implementations of both Pung and Addra.

Most PIR schemes(such as SealPIR \cite{angel2018pir}, MulPIR \cite{ali2021communicationcomputation} and FastPIR \cite{ahmad2021addra}) use an underlying homomorphic public key cryptosystem, commonly the BFV cryptosystem \cite{fan2012somewhat}. In BFV, generating the public-private keypair is expensive. In the implementations of many MPM systems such as Pung and Addra, each client generates a keypair $(\pk_{\pir}, \sk_{\pir})$ once and use them in all PIR queries $\ct = \query(1^{\lambda}, \sk_{\pir}, i)$. Previously, this optimization is regarded safe since it preserves UO-ER security defined in \cite[Extended Version]{angel2016unobservable}. However, this design creates a serious security hole in messaging systems, as we detail below.

Suppose at time $T_0$, honest user $A$ sends a PIR request $\ct$ to the server. Malicious user $C$, colluding with the server, wishes to know if $\ct$ is a query to honest user $B$'s mailbox at index $i_B$. The attack depends on three requirements.
\begin{itemize}
    \item User $A$ is going to have a conversation with a malicious user $C$ at a future time $T_1 > T_0$. 
    \item User $A$ does not switch PIR keypair between time $T_0$ and $T_1$.
    \item User $A$ will provide "feedback" $f(m)$ to user $C$'s message $m$. This could be an $\ACK$ message in our system (See \cref{subsec:ACK}), or simply a verbal response to $C$'s message.  
\end{itemize}

The attack goes as follows. At time $T_0$, the server stores $\ct$, and continues to serve $A$ honestly until time $T_1$. During $A$ and $C$'s conversation, the server responds to $A$'s PIR with $\resp = \answer^{DB'}(1^{\lambda}, \ct)$, where $DB'[i_B]$ is a valid message $m$ from $C$ to $A$, and $DB'[i] = 0$ for any $i \neq i_B$. If $\ct$ is a query to $i_B$, $A$ will receive the message from $C$ and sen feedback to $C$. Otherwise, $A$ will not receive a message from $C$ and not send feedback to $C$. Therefore, $C$ can observe $A$'s feedback and learn if $\ct$ is a query to $i_B$ or not.

This attack can be prevented by changing the PIR keypair each round, which is ok for Anysphere because of our low clientside computation requirement. However, it provides evidence that a secure PIR system does not guarantee metadata security of the whole system.

\textbf{Note}: In \cite{henry2022simplepir}, Henzinger et. al. discovered another attack exploiting the same keypair reuse issue. The two attacks are fundamentally different. The attack proposed in \cite{henry2022simplepir} is on the primitive level, specific to the BFV cryptosystem, and assumes the attacker has full access to the clients' decryption oracle. In contrast, our attack is on the protocol level, applies to any PIR scheme based on public key homomorphic encryption, and makes no assumption on the feedback the attacker provides.

\subsection{The Impersonation Attack} 
We next describe an attack on the trust establishment system $\trust(\cdot)$. Due to a lack of central authorities, our system uses the registration information $\reg$ as the unique identifier of a client / user. The registration information is a tuple $\reg = (i, \kx^P)$ containing the index $i$ of the client in the PIR database, and the key exchange public key $\kx^P$ of the client. This information is intended to be posted on the client / user's social media, so that others can verify that the registration info indeed belongs to the person.

Suppose user $A, B$ are friends, and their registration informations are $\reg_A = (i_A, \kx^P_A)$ and $\reg_B = (i_B, \kx^P_B)$ respectively. Then a malicious user $C$ can declare on their webpage that their registration information is $\reg_C = (i_C, \kx^P_B)$. If user $A$ establishes trust with user $C$, then user $B$ will ``overhear" all conversations between user $A$ and user $C$, since the way $B$ decides if a message from $A$ is meant for them is by decrypting user $A$'s ciphertext with their shared public key $\sk_{AB}$ (see \cite[Figure 3]{whitepaper}). By letting $\sk_{AC} = \sk_{AB}$, user $C$ compromised the integrity of user $A$ and $B$'s conversation defined in \cref{defn:messaging-integrity}.

There are many ways to resolve this issue, such as adding a signature to the registration information, or labeling each message with their intended recipient. This attack is more of a subtlety in the proof, and motivates the Eval-security definition \cref{defn:AE-eval-security}.