\section{The PIR Replay Attack}
\label{sec:security-vulnerable}

In this section, we present the PIR Replay Attack mentioned in the Introduction. While the CF attacks in \cite{angel2018cf} can only reveal the number of friends each honest user has, this attack can potentially reveal the sender and recipient of a PIR request if the recipient has a compromised friend. The vulnerability affects existing implementations of both Pung and Addra, and is easy to implement in practice.

Most PIR schemes(such as SealPIR \cite{angel2018pir}, MulPIR \cite{ali2021communicationcomputation}, FastPIR \cite{ahmad2021addra}, and Spiral \cite{wu2022spiral}) use an underlying homomorphic public key cryptosystem, typically some variation of the BFV cryptosystem \cite{fan2012somewhat}. Generating the necessary keypairs in these cryptosystems is expensive. To improve performance, real world implementations of FastPIR and Spiral reuse PIR keys. Each client generates a secret $\sk_{\pir}$ once and use them to encrypt all PIR queries $\ct = \query(1^{\lambda}, \sk_{\pir}, i)$. This optimization was regarded safe since it preserves the UO-ER security notion defined in \cite[Extended Version]{angel2016unobservable}. Now we show how to combine this optimization with compromised friend to leak metadata.

Suppose the adversary suspects that honest users $A$ and $B$ are communicating. Also suppose that honest user $A$ has a compromised friend $C$. At time $T_0$, user $A$ sends a PIR request $\ct$ to the server. The adversary wishes to know if $\ct$ is a query to honest user $B$'s mailbox at index $i_B$. Assume that
\begin{itemize}
    \item User $A$ will have a conversation with user $C$ at a future time $T_1 > T_0$. 
    \item User $A$ does not switch PIR keypair between time $T_0$ and $T_1$.
    \item User $A$ will provide "feedback" $f(m)$ to user $C$'s message $m$. This could be any nonempty response to $C$'s message, such as the $\ACK$ message in our system (See \cref{subsec:ACK}).
\end{itemize}

At time $T_0$, the server stores $\ct$, and continues to serve $A$ honestly until time $T_1$. During $A$ and $C$'s conversation, the server responds to $A$'s PIR with $\resp = \answer^{DB'}(1^{\lambda}, \ct)$, where $DB'[i_B]$ is a valid message $m$ from $C$ to $A$, and $DB'[i] = 0$ for any $i \neq i_B$. If $\ct$ is a query to $i_B$, $A$ will receive the message from $C$ and send feedback to $C$. Otherwise, $A$ will not receive a message from $C$ and not send feedback to $C$. Therefore, $C$ can observe $A$'s feedback and learn if $\ct$ is a query to $i_B$ or not.

This attack can be prevented by changing the PIR keypair each round, which is ok for Anysphere because of our low clientside computation requirement. However, it shows that compromised friend can do more damage to private messaging systems than previously known.

\textbf{Note}: In \cite{henry2022simplepir}, Henzinger et. al. discovered another attack exploiting the same keypair reuse issue. The two attacks are fundamentally different. The attack proposed in \cite{henry2022simplepir} is on the primitive level, specific to the BFV cryptosystem, and assumes the attacker has full access to the clients' decryption oracle. In contrast, our attack is on the protocol level, applies to any PIR scheme based on public key homomorphic encryption, and makes no assumption on the feedback the attacker provides.

\todo{Impersonation attack is not understandable unless you know exactly how Anysphere is implemented, so I removed it}