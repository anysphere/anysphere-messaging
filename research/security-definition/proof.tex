\newcommand{\MSGS}{\text{MSGSent}}
\newcommand{\msgs}{\text{msgsent}}
\newcommand{\MSGR}{\text{MSGRecv}}
\newcommand{\cD}{\mathcal{D}}

\section{Proofs}
In this section, we prove that our messaging scheme satisfies \cref{defn:correctness}, \cref{defn:SIM-secure}, and \cref{defn:integrity}. These definitions establish correctness, security, and integrity respectively.
\subsection{Proof of Correctness}
To show \cref{defn:correctness}, we need to show our two consistency models: Consistent Prefix and Eventual Consistency.

We first introduce some notations for convenience. Define
\begin{multline*}
    \MSGS(t_0, i, j) = \{(t, \msg): \send(\reg_j, \msg) = \cI_{i, t} \land \\
             \exists t' < t, \trust(\reg_j) = \cI_{i, t'}\}
\end{multline*}
and let $\msg_{ij}(\ell)$ be the $\ell$-th message in $\MSGS(t_0, i, j)$, sorted by time $t$. Let $\msg_{ij}^{lb}(\ell) = (\ell, \msg_{ij}(\ell)).$

\textbf{Consistent Prefix}: We establish the following property by induction.
\begin{lemma}
\label{lem:correctness-main}
In the honest server experiment \cref{defn:honest-server-experiment}. Let $i \neq j$ be any pair of users, and $t \leq T$. Then with probability $1 - \negl(\lambda)$, at the end of timestep $t$ the proposition below holds.

\textbf{Proposition: }One of the following holds.

1) $\reg_j \notin C_i.\frienddb$, and $C_i.\outb[\reg_j] = C_j.\inb[\reg_i] = \emptyset$.

2) $\reg_j \in C_i.\frienddb$. Then $\msg_{ij}(\ell)$ is labeled with sequence number $\ell$ for any $\ell$. Furthermore, we let
\begin{align*}
S_t &= C_i.\frienddb[\reg_j].\seqs, \\
E_t &= C_i.\frienddb[\reg_j].\seqe, \\
R_t &= C_j.\frienddb[\reg_i].\seqr,
\end{align*}
(we define $R_t = 0$ if $\reg_i \notin C_j.\frienddb$). Then we have $S_t \in \{R_t, R_t + 1\}$, and
$$\abs{\MSGS(t, i, j)} = E_t,$$
$$C_i.\outb[\reg_j] = \{\msg^{lb}_{ij}(S_t), \cdots, \msg^{lb}_{ij}(E_t)\},$$
$$C_j.\inb[\reg_i] = \{\msg_{ij}(1), \cdots, \msg_{ij}(R_t)\}.$$
\end{lemma}
\begin{proof}
When $t = 0$, 1) is satisfied since $C_i.\frienddb$ is initialized as empty. We now show if these properties hold for all timesteps before $t$, then they will hold at the end of timestep $t$ with probability $1 - \negl(\lambda)$.

The relevant variables are only modified in Phase 1 of $C_i.\mathsf{UserInput}$, in $C_i.\mathsf{ServerRPC}$ and in $C_j.\mathsf{ServerRPC}$. We show that the lemma is satisfied after each of these methods(no matter which order they execute).

Phase 1 of $C_i.\mathsf{UserInput}$
\hrule
If 1) holds before timestep $t$ starts, then unless 
$$\cI = \trust(\reg_j),$$
none of the variable will be changed. Otherwise, we will have $S_t = 1, E_t = E_t = 0$, and both $C_i.\outb[\reg_j] = C_j.\inb[\reg_i] = \emptyset$, which satisfies 2).

If 2) holds before timestep $t$ starts, then unless $\cI = \send(\reg_j, \msg)$ none of the variable will be changed. Otherwise, $E_t = E_{t - 1} + 1$. We can check that
$\MSGS(t, i, j) = \MSGS(t, i, j) + (t, \msg).$
Thus we have
$$\abs{\MSGS(t, i, j)} = \abs{\MSGS(t - 1, i, j)} + 1 = E_t.$$
Furthermore, we have $\msg = \msg_{ij}(E_t)$, and it will be labeled with sequence number $E_t$ by step (3). Thus $\msg^{lb} = \msg^{lb}_{ij}(E_t)$, so the equality with $C_i.\outb[\reg_j]$ is maintained. All the other variables remain unchanged, thus all the desired properties remain true.

\vspace{10pt}
$C_i.\mathsf{ServerRPC}$
\hrule
The relevant variables will be changed only during ACK decipher when a request is sent during Phase 2 of $C_i.\mathsf{UserInput}$. Let $j' = i_r$ be the PIR index chosen in that phase. No relevant variable changes if $j' \neq j$, so assume $j' = j$. Then by the correctness of $\Pi_{\pir}$, we have
\begin{align*}
 \ct_{\ack} &= \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\ack})   \\
 &= \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, \Pi_{\pir}.\answer^{\ackdb}(1^{\lambda}, \pk_{\pir}, \ct_{\query})) \\
 &= \ackdb[j'].
\end{align*}
Let $t'$ be the last time user $j$ sends a nonempty request the server, and suppose they chose $\reg_s = (i', \_)$ that time. Then
$$\ct_{\ack} = \Pi_{\sym}.\Enc(sk_{ji'}, a)$$
where $\sk_{ji'} = \Pi_{\sym}.\mathsf{KX}(kx_{i'}^P, kx_{j}^S)$, and $a$ is the ACK message. Thus, in step (1) of ACK decipher, we have
$$\ack = \Pi_{\sym}.\Dec(sk_{ij}, \Pi_{\sym}.\Enc(sk_{ji'}, a)).$$
If $i' \neq i$, we have $sk_{ij} \neq sk_{ji'}$ with probability $1 - \negl(\lambda)$ by the security of $\Pi_{\sym}$. In this case, $\ack = \bot$ by the correctness of $\Pi_{\sym}$, so no relevant variable is changed. 

If $i' = i$, by the correctness of $\Pi_{\sym}$ we have $\ack = a$. By the protocol definition, we conclude that
$$\ack = \ACK(R_{t' - 1}).$$
In step (7.c), we have $C_i.\frienddb[\reg_j].\seqs = S_{t - 1}$. By the induction hypothesis, we have
$$S_{t - 1} \geq R_{t - 1} \geq R_{t' - 1}.$$
So no variable is changed unless $S_{t - 1} = R_{t - 1} = R_{t' - 1}$, in which case $S_t = R_{t - 1} + 1$, and after popping $\msg^{lb}_{ij}(S_{t - 1})$ we get
$$C_i.\outb[\reg_j] = \{\msg^{lb}_{ij}(S_{t - 1} + 1), \cdots, \msg^{lb}_{ij}(E_t)\}.$$
Thus, the desired properties still hold.

\vspace{10pt}
$C_j.\mathsf{ServerRPC}$
\hrule
The relevant variables will be changed only during message decipher when a request is sent during Phase 2 of $C_j.\mathsf{UserInput}$. Let $i' = i_r$ be the PIR index chosen in that phase. No relevant variable changes if $i' \neq i$, so assume $i' = i$. Analogous to the previous analysis, let $t'$ be the last time user $i$ sends a nonempty request the server, and suppose they chose $\reg_s = (j', \_)$ that time. Then
if $j' \neq j$, we have $\msg^{lb} = \bot$ with probability $1 - \negl(\lambda)$, and no relevant variable will be changed. If $j' = j$, we have
$$\msg^{lb} = \begin{cases}
(-1, 0^{L_{\msg}}), S_{t' - 1} > E_t'. \\
\msg_{ij}^{lb}(S_{t' - 1}), S_{t' - 1} \leq E_{t'}. 
\end{cases}$$
In the first case the message is ignored. In the second case the message is also ignored unless $S_{t' - 1} = R_{t - 1} + 1$. By the induction hypothesis, this is possible only if $S_{t - 1} = S_{t' - 1} = R_{t - 1} + 1$. In this case, we have $R_t = R_{t - 1} + 1 = S_{t - 1}$, , and after popping $\msg_{ij}(S_{t - 1})$ we get
$$C_i.\outb[\reg_j] = \{\msg^{lb}_{ij}(1), \cdots, \msg^{lb}_{ij}(S_{t - 1})\}.$$
Thus, the desired properties still hold.

We have proven that the desired properties hold at the end of timestep $t$ with probability $1 - \negl(\lambda)$.
\end{proof}
We can now prove Consistent Prefix as defined in \cref{defn:correctness}. We use the notation of \cref{lem:correctness-main}. Let $(\cF, \cM) = C_j.\mathsf{GetView}()$. We take $t(j) = T_0$. Unpacking the definition of $\cF$ and $\cM$, we need to verify that for each $i \in [N]$, with probability $1 - \negl(\lambda)$ there exists a $t(i) \leq T_0$ such that
 
 a) $\reg_i \in C_j.\frienddb$ if and only if there exists a $t \leq T_0$ such that 
 $$\trust(\reg_i) = \cI_{j, t}.$$
 b) We have
 \begin{multline*}
 C_j.\inb[\reg_i] = \{\msg: \exists t \leq t(i), \send(\reg_j, \msg) = \cI_{i, t} \land \\
 \exists t' < t, \trust(\reg_j) = \cI_{i, t'} \land \\
 \exists t'' \leq T_0, \trust(\reg_i) = \cI_{j, t''}\}.   
 \end{multline*} 
 That a) holds is easy to see, since by the protocol definition, $\reg_i$ is inserted into $C_j.\frienddb$ during timestep $t$ if and only if $\trust(\reg_i) = \cI_{j, t}$, and it is never removed. 
 
 We next verify (b). If $i = j$, then the equation holds for $t(j) = T_0$ since messages to oneselve are deposited to $C_j.\inb$ immediately by protocol. Now assume $i \neq j.$ 
 
 We show that $t(i)$ exists as long as \cref{lem:correctness-main} holds at the current timestep $T_0$. We consider which scenario in the lemma holds. 
 
 If 1) holds, we let $t(i) = T_0$. In this case, both sides of the equation are emptysets.
 
 If 2) holds, we let $t(i) = T_0$ if $\reg_i \notin C_j.\frienddb$ at the current timestep, otherwise let $t(i)$ be the timestep before $C_i.\send(\reg_j, \msg_{ij}(R_{t} + 1))$ is called(or the current timestep if $\msg_{ij}(R_{t} + 1)$ does not exist). If $\reg_i \notin C_j.\frienddb$, we have $R_t = 0$, so both sides of the equation are empty sets. Otherwise, by the definition of $\msg_{ij}(\ell)$, both sides of the equation are equal to $\{\msg_{ij}(1),\cdots, \msg_{ij}(R_t)\}$. So we have shown the Consistent Prefix property in all cases where the proposition in \cref{lem:correctness-main} holds for all users $i \neq j$, thus with probability $1 - \negl(\lambda)$.
 
 \textbf{Eventual Consistency}: We use the same choice of $t(i)$. Let $T_{cons} = 2\lambda B^2 T^U_{\mathsf{trans}} \cdot T_1 + T_1.$ We show that this $T_{cons}$ satisfies the desired property. 
 
 We wish to show that if $T_0 \geq T_{cons}$, then with probability $1 - \negl(\lambda)$ we have $t(i) \geq T_1$. Let $E = \abs{\MSGS(T_1, i, j)}$(Note $E$ is independent of the protocol execution). If $R_{T_1} \geq E$, then by casework on the definition we always have $t(i) \geq T_1$. So it suffice to show that $R_{T_1} < R$ with negligible probability. 
 
 We use the same notation as \cref{lem:correctness-main}. For each $k \leq E$, let $X_k$ be the random variable denoting the first $t$ such that $R_t \geq k$, with $X_0 = 0$. Let $Y_k$ denote the first $t$ such that $S_{t} > k$. It suffices to show that for any $k \leq E$, we have
 $$Y_k - X_k > \lambda B^2 T^U_{\mathsf{trans}}$$
 or
 $$X_{k} - \max(Y_{k - 1}, T_1) > \lambda B^2 T^U_{\mathsf{trans}}$$
 with negligible probability. To see the former possibility, for each timestep $t$ between $X_k$ and $X_{k + 1}$ such that $t$ divides $C_i.T_{\mathsf{trans}}$, let $j_t$ be the $i_r$ that $C_i$ chooses, and let $i_t$ be the $i_s$ that $C_j$ chooses for their last non-empty request to the server before timestep $t + 1$. If $(i_t, j_t) = (i, j)$, we must have $S_{t} \geq k + 1$ by the protocol definition. Furthermore, if we let $K = \ceil{T^U_{\mathsf{trans}} / C_i.T_{\mathsf{trans}}}C_i.T_{\mathsf{trans}}$, then the random variables
 $$(i_t, j_t), (i_{t + K}, j_{t + K}), \cdots$$
are independent of each other, since both $i$ and $j$ must have both made a non-empty request to the server between timestep $(t, t + K]$. Therefore, the probability that $Y_k - X_k > \lambda B^2 T^U_{\mathsf{trans}}$ is at most
$$(1 - B^{-2})^{\lambda B^2 T^U_{\mathsf{trans}} / K} = \negl(\lambda)$$
as desired. The proof for the latter possibility is analogous. Thus, we have demonstrated eventual consistency for the Anysphere protocol.
\subsection{Proof of Security}
In this section we show that our scheme is SIM secure. The security of our system is essentially implied by the IND-CPA security of the underlying symmetric key protocol $\Pi_{\sym}$ and the SIM security of the pir protocol $\Pi_{\pir}$. We now justify this by constructing a simulator $\Sim_{\asphr}$ that satisfied \cref{defn:SIM-secure}.

Let $N$ be the number of honest clients, and take $R = 2N(\lambda)T(\lambda)$. Let $\Sim_{\sym}$ and $\Sim_{\pir}$ be the simulators defined in \cref{defn:sym-security} and \cref{defn:pir-security} respectively, with parameters $N$ and $R$. At step (2), (4.a), and (4.c) of \cref{defn:ideal-world}, our simulator will run modified versions of the corresponding client methods in the respective steps of \cref{defn:real-world} for each $i \in \cH$. The important modifications involve replacing all lines that involve unleaked information.

We now describe these modifications. Changes are marked in red.
\todo{Hard-coded. Please modify if the $\Pi_{\asphr}$ methods get changed.}

\vspace{10pt}

$\mathbf{\Sim_{\asphr}.\mathsf{Register}}(1^{\lambda}, i, N)$
\vspace{5pt}
\hrule
\vspace{5pt}
No modification. For each $i$, let $kx^P_i$ be $\reg[1]$ for client $i$.
\vspace{10pt}

$\mathbf{\Sim_{\asphr}.\mathsf{Input}}(t, i, {\color{red} \textbf{Hybrid 3:} \text{replace $\cI$ with $\Leak$}})$
\vspace{5pt}
\hrule
\vspace{5pt}
Phase 1: 

{
\color{red} 

\textbf{Hybrid 3}:

Initialize $\cI$.

\begin{enumerate}
    \item If $(i, \reg, t) \in \Leak_f$, $\cI \leftarrow \trust(\reg)$.
    \item If $(i, \reg, \msg, t) \in \Leak_m$, $\cI \leftarrow \send(\reg, \msg)$.
    \item Else, $\cI \leftarrow \emptyset$.
\end{enumerate}

}

If $\cI = \emptyset$, do nothing. 

If $\cI = \send(\reg, \msg)$, 

\begin{enumerate}
    \item Check that $\msg$ has length $L_{\msg}$. If not, skip to Phase 2.
    \item Check that $\reg$ is in $\frienddb$. If not, skip to Phase 2.
    \item If $\reg$ is the registration of $C_i$ itself, append $\msg$ to $\inb[\reg]$, and skip to Phase 2. \footnote{Skipping this step breaks consistent prefix.}
    \item Add $1$ to $\frienddb[\reg].\seqe$. 
    \item Push $\msg^{lb} = (\frienddb[\reg].\seqe, \msg)$ to $\outb[\reg]$.
\end{enumerate}

If $\cI = \trust(\reg)$.
\begin{enumerate}
    \item Check if $\reg$ is in $\frienddb$. If so, skip to Phase 2.
    \item $(i, kx_f^P) \leftarrow \reg$.
    \item $sk \leftarrow \Pi_{\sym}.\mathsf{KX}(1^{\lambda}, kx_f^P, kx^S).$
    \item $\frienddb[\reg] \leftarrow \{\sk: sk,  \seqs: 1, \seqe: 0, \seqr: 0\}$.
\end{enumerate}

Phase 2:
\begin{enumerate}
    \item If $t$ is not divisible by $T_{\trans}$, return $\emptyset$.
    \item Let $\{\reg_1, \cdots, \reg_k\}$ be the keys of $\frienddb$, with $k\leq B$. Construct $S = [\reg_1,\cdots, \reg_k, \reg, \cdots, \reg]$, where we add $B - k$ copies of $\reg$, our own registration info. Sample $\reg_s, \reg_r$ uniformly and independently at random from $S$. 
    \item Let $\msg$ be the (labeled) message with sequence number $\frienddb[\reg_s].\seqs$ in $\outb[\reg_s]$. If $\outb[\reg_s]$ is empty, let $\msg = (-1, 0^{L_{\msg}})$.
    \item $\sk \leftarrow \frienddb[\reg_s].\sk$. If $\reg_s$ does not exist in $\frienddb$, randomly generate a secret key $\_, \sk \leftarrow \Pi_{\sym}.\gen(1^{\lambda}).$
    \item $\seqr \leftarrow \frienddb[\reg_s].\seqr$.
    \item Encrypt Messages with $\sk$.
    
    {\color{red} 
    \textbf{Hybird 1}:
    
    If $\reg_s \in \reg_\cH$, 
    \begin{itemize}
        \item $\ct_{\msg} \leftarrow \Sim_{\sym}(1^{\lambda},\{(kx_i^P, kx_i^S)\}_{i \in \cH}),$
        \item $\ct_{\ack} \leftarrow \Sim_{\sym}(1^{\lambda},\{(kx_i^P, kx_i^S)\}_{i \in \cH}),$
    \end{itemize}
    Else, 
    }
    
    
    \begin{itemize}
        \item $\ct_{\msg} = \Pi_{\sym}.\enc(\sk, \msg).$
        \item $\ct_{\ack} = \Pi_{\sym}.\enc(\sk, \ACK(\seqr))$.
    \end{itemize}
    \item Let $\reg_r = (i_r, \_)$. Formulate a PIR request for index $i_r$. 
    
     {
     \color{red}
          
     \textbf{Hybird 2}:
         
     If $\reg_r \in \reg_{\cH}$, 
    \begin{itemize}
        \item $\ct_{\query} \leftarrow \Sim_{\pir}(1^{\lambda}, n).$
    \end{itemize}
    Else, 
    }
    \begin{itemize}
        \item $\ct_{\query}, \sk_{\pir} \leftarrow \Pi_{\pir}.\query(1^{\lambda}, i_r).$
    \end{itemize}
    \item return $\req = (\ct_{\msg}, \ct_{\ack}, \pk_{\pir}, \ct_{\query})$.
    \item Remember $\reg_r$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{ServerRPC}}(t, \resp)$
\vspace{5pt}
\hrule
\vspace{5pt}
{\color{red} \textbf{Hybrid 1'}: if $\reg_r \in \reg_{\cH}$, return.}
\begin{enumerate}
    \item If $\resp = \emptyset$, ignore.
    \item Parse $\resp = (a_{\msg}, a_{\ack})$. Let $\reg_r, \sk_{\pir}$ be defined in the last call to $\Pi_{\asphr}.C.\mathsf{Input}$.
    \item $\ct_{\msg} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\msg}).$
    \item $\ct_{\ack} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\ack}).$
    \item $\sk \leftarrow \frienddb[\reg_r].\sk$.
    \item Decipher the message.
    \begin{enumerate}
        \item $\msg^{lb} \leftarrow \Pi_{\sym}.\Dec(1^{\lambda}, \sk, \ct_{\msg})$.
        \item If $\msg^{lb} = \bot$ or $\msg^{lb}[0]$ is not $\frienddb[\reg_r].\seqr + 1$, ignore the message.
        \item Add $1$ to $\frienddb[\reg_r].\seqr$. 
        \item Let $\msg$ be $\msg^{lb}[1]$. Push $\msg$ to $\inb[\reg_r]$.
    \end{enumerate}
    \item Decipher the ACK.
    \begin{enumerate}
        \item $\ack \leftarrow \Pi_{\sym}.\Dec(1^{\lambda}, \sk, \ct_{\ack})$.
        \item If $\ack = \bot$ or $\ack$ is not the form $\ACK(k)$ for some $k$, ignore the ack.
        \item Let $\ack = \ACK(k)$. If $k < \frienddb[\reg_r].\seqs$, ignore the ack.
        \item $\frienddb[\reg_r].\seqs \leftarrow k + 1$. Remove the message with sequence number $k$ from $\outb[\reg_r]$.
    \end{enumerate}
\end{enumerate}

We use a hybrid argument to show that the two views are indistinguishable. We start from the original implementation of the client methods $\Pi_{\asphr}.C$, and use a hybrid argument to transform it into the simulator methods $\Sim_{\asphr}$. We call the Real World Experiment $\Hyb_0$.  

\todo{The first hybrid here uses a very strong $\Eval$ oracle. The reason is the following: if an adversary $\cA$ exists that breaks indistinguishability, then we want to construct an adversary $\cA_1$ that breaks our security definition \cref{defn:sym-security}. $\cA_1$ has to "simulate" the view of $\cA$ while only knowing the public key of the adversaries. Now assume the adversary $\cA$ establishes trust with a certain malicious public key $k$. Then $\cA_1$ must be able to accurately simulate all the internal state changes related to this public key, since the associated ACKs and messages are contained in the view of $\cA$. On the other hand, $\cA_1$ cannot possibly do this with only the encryption oracle, since $k$ might not have a computable private key. So the Eval oracle comes to the rescue.}

\todo{If we can somehow bypass this issue, the length of the paper can be reduced by at least 5 pages. So please share any possible ideas.}

First Hybrid: We add the statements marked Hybrid 1 and run the experiment in \cref{defn:real-world}. We call this modified experiment $\Hyb_1$. To argue this preserves indistinguishability, suppose on the contrary that an adversary $\cA$ and a distinguisher $\cD$ can distinguish the view before and after the modification. Then we can build an adversary $\cA_1^O$ and a distinguisher $\cD'$ breaking \cref{defn:sym-security}. 

For the adversary $\cA_1^O$ to simulate the experiment in \cref{defn:real-world}, the key idea is to choose a powerful function $f: \Sigma^* \times \Sigma^* \to \Sigma^L$. For each $\reg = (j, kx^P)$, define $\data[\reg] = (\frienddb[\reg], \inb[\reg], \outb[\reg])$. $\cA_1$ stores a log of changes to $\data$ \textbf{encrypted using $\sk = \KX(kx^P, kx_i^S)$}. Whenever it wants to access or update these data in the client simulation, it calls $\Eval_f(kx_i^S, kx^P, \cdot)$. We choose $f$ to decrypt the log, recover the plaintext of the fields, do the corresponding simulation, then re-encrypt the outputs and updates to the log ($f$ can use $\arg_p$ to determine which line it is on). For such an $f$, $\cA_1^O$ can use $f$ to perfectly simulate client updates on the $\sk$-encrypted $\data[\reg]$. Finally, note that any client outputs computed from $\data$ are $\sk$-encrypted, so $f$ can perfectly simulate client outputs as well. 

With this choice of $f$, we describe the full $\cA_1^O$. The step numbers below refers to the steps in \cref{defn:real-world} unless otherwise indicated.
\begin{itemize}
    \item Simulate $\cA$ in step (1), (3), (4.b).
    \item On step (2), $\reg_i \leftarrow (i, kx_i^{P})$ for each $i \in \cH$. 
    \item On step (4.a), iterate over $i \in \cH$. $\cA_1$ simulates client $i$'s action in $\Pi_{\asphr}.\mathsf{Input}$ verbatim until Phase 2 Step (6). In Step (6), $\cA_1$ do casework based on if $\reg_s \in \reg_{\cH}$. 
    \begin{itemize}
        \item  If $\reg_s \notin \reg_{\cH}$, $\cA_1$ uses $\Eval_f$ to simulate the rest of the client actions
        \item  If $\reg_s \in \reg_{\cH}$, assume $\reg_s = \reg_j$. $\cA_1$ sets $(\ct, \arg_p)$ so that $\Eval_f(kx^S_i, kx^P_j, \ct, \arg_p)$ can simulate the original step (6) to compute $\ct_{\msg}$, outputs $(i, j, \ct, \arg_p)$, then moves to line (4.b) in \cref{defn:sym-security}. $\cA_1$ sets $\ct_{\msg} = \ct^b_r$ to be the output of line (4.b). $\cA_1$ repeats this for $\ct_{\ack}$.
    \end{itemize}
   
    \item On step (4.c), $\cA_1$ simulates client action in $\Pi_{\asphr}.\mathsf{ServerRPC}$ using $\Eval_f$.
\end{itemize}
We note that if $b = 0$, i.e. in the real world experiment of \cref{defn:sym-security}, $\cA_1$ perfectly simulates the view of $\cA$ in $\Hyb_0$, while if $b = 1$, i.e. in the ideal world experiment of \cref{defn:sym-security}, $\cA_1$ perfectly simulates the view of $\cA$ in $\Hyb_1$. Thus, $\cA_1$ just need to output the view of $\cA$ at the end of the simulation, and the same distinguisher $\cD' = \cD$ is able to distinguish between the views of $\cA_1$ in the real and ideal world. This contradicts our assumption that $\Pi_{\sym}$ satisfies \cref{defn:sym-security}. Therefore, we finally conclude that
$$\Hyb_0 \equiv_c \Hyb_1.$$

Corollary of First Hybrid: We add the statements marked Hybrid 1' and run the experiment in \cref{defn:real-world}. We call this modified experiment $\Hyb_{1'}$.

We argue that this hybrid does not change the adversary's view at all: the only thing $\Pi_{\asphr}.C.\mathsf{ServerRPC}$ does is update fields of $\data[\reg_r]$. Note that in $\Hyb_1$, for any $\reg \in \reg_{\cH}$, the fields of $\data[\reg]$ does not affect the output of the client. So adding the statement marked Hybrid 1' does not affect the output of the client. We conclude that
$$\Hyb_1 \equiv_c \Hyb_{1'}.$$

Second Hybrid: We add the statements marked Hybrid 2, and run the experiment in \cref{defn:real-world}. We call this modified experiment $\Hyb_{2}$.

We now show that $\Hyb_{1'}$ and $\Hyb_{2}$ are indistinguishable. Suppose on the contrary that an adversary $\cA$ and a distinguisher $\cD$ can $\Hyb_{1'}$ and $\Hyb_{2}$. Then we can build an adversary $\cA_2$ and a distinguisher $\cD'$ breaking \cref{defn:pir-security}. 

$\cA_2$ simulates a modified version of $\Hyb_1$. $\cA_2$ simulates line (1, 2, 3, 4b, 4c) in \cref{defn:real-world} verbatim as in both $\Hyb_{1'}$ and $\Hyb_2$. On line (4a), $\cA_2$ simulates everything but Phase 2 step (7) verbatim. When it reaches Phase 2 step (7), if $\reg_r \notin \reg_{\cH}$ then it simulates this step verbatim as well. If $\reg_r \in \reg_{\cH}$, then $\cA_2$ returns $i_r$ and exits line (1a) of the experiment in \cref{defn:pir-security}. Let $\ct^b_r$ be the return value of line (1b). $\cA_2$ sets $\ct_{\query} = \ct^b_r$ and continues simulation.

Note that contrary to the previous scenario, $\cA_2$ knows all the key exchange secret keys. Furthermore, if $\reg_r \notin \reg_{\cH}$, $\cA_2$ knows $\sk_{\pir}$ generated by $\Pi_{\asphr}.C.\mathsf{Input}$. If $\reg_r \notin \reg_{\cH}$, then $\cA_2$ does not know the $\sk_{\pir}$, but this $\sk_{\pir}$ will never be used since Hybrid 1' ensures that $\Pi_{\asphr}.C.\mathsf{ServerRPC}$ is skipped. Thus, we conclude that $\cA_2$ can complete the simulation.

Note that in the real world experiment of \cref{defn:pir-security}, $\cA_2$ simulates $\Hyb_{1'}$ verbatim, while in the ideal world experiment of $\cref{defn:pir-security}$, $\cA_2$ simulates $\Hyb_2$ verbatim. Thus, $\cA_2$ just need to output the view of $\cA$ at the end of the simulation, and the same distinguisher $\cD' = \cD$ is able to distinguish between the views of $\cA_1$ in the real and ideal world. This contradicts our assumption that $\Pi_{\pir}$ satisfies \cref{defn:pir-security}. Therefore, we conclude that
$$\Hyb_{1'} \equiv_c \Hyb_2.$$
Third Hybrid: We add the statements marked Hybrid 3, and run the experiment in \cref{defn:real-world}. We call this modified experiment $\Hyb_{3}$. This modification does not change the view of the adversary at all: after all the changes in Hybrid 1, 1' and 2, for any $\reg \in \reg_{\cH}$, the contents of $\frienddb[\reg], \inb[\reg], \outb[\reg]$ does not affect the client's output. In particular, the way $\reg_s$ and $\reg_r$ are selected ensures that whether $\reg$ lies in $\frienddb$ or not does not affect the distribution of $\reg_s$ or $\reg_r$. For any $\reg \notin \reg_{\cH}$, Hybrid 3 does not affect how $\frienddb[\reg], \inb[\reg], \outb[\reg]$ are updated. So we have shown
$$\Hyb_{2} \equiv_c \Hyb_3.$$
We can now conclude that
$$\Hyb_0 \equiv_c \Hyb_3$$
Note that $\Hyb_0$ is equal to the real world experiment, and $\Hyb_3$ is equal to the ideal world experiment. Therefore, $\Pi_{\asphr}$ satisfies \cref{defn:SIM-secure} as desired. 


