\section{Definition of Anysphere}
\label{sec:asphr-defn}
In this section, we define in detail the Anysphere core protocol described in our whitepaper \cite{whitepaper}. 
\subsection{Cryptography Primitives}
Anysphere relies on two cryptographical primitives: a symmetric key authenticated encryption(AE) system, and a PIR scheme. We outline formal simulator-based security definitions of the two.

It turns out that our security definition of the PIR scheme is standard and well-documented in literature. However, existing security definitions on the AE system , including IND-CCA2 or even IK-CCA(\cite{BBDP01keyprivate}), are not sufficient. In this section, we introduce a security requirement, called Eval Security, that is sufficient to establish the security of our system.
\subsubsection{Authenticated Encryption System}
\label{subsec:AE}
Our AE scheme consists of a quadruple of algorithms $(\gen, \KX, \enc, \dec)$ with specifications
\begin{itemize}
    \item $\gen(1^{\lambda}) \to (\kx^P, \kx^S)$,
    \item $\KX(\kx_A^P, \kx_B^S) \to \sk_{AB},$
    \item $\enc(\sk_{AB}, m) \to ct,$
    \item $\dec(\sk_{BA}, \ct) \to m.$
\end{itemize}
We require this scheme to be correct, secure, and unforgable. These properties are precisely defined below. Correctness is standard, but security and authentication definitions seem to be non-standard.
\begin{definition}
\label{defn:AE-correctness}
Let
\begin{enumerate}
    \item $(\kx^P_A, \kx_A^S), (\kx^P_B, \kx_B^S)  \leftarrow \gen(1^{\lambda}).$
    \item $\sk_{AB} \leftarrow \KX(\kx_A^P,\kx_B^S), \sk_{BA} \leftarrow \KX(\kx_B^P, \kx_A^S).$
\end{enumerate}
We say our AE scheme is \textbf{correct} if with probability 1, we have $\sk_{AB} = \sk_{BA}$, and for any plaintext $m$ of length $L_{\ae}$, we have
$$\dec(\sk_{BA}, \enc(\sk_{AB}, m)) = m.$$
\end{definition}
\textbf{Remark}: In our implementation, we take $L_{\ae} = 1 \mathsf{KB}$.
\begin{definition}
\label{defn:AE-eval-oracle}
Given a key exchange secret key $\kx^S$, and a polynomial time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$, the \textbf{Eval oracle} $\Eval_{f}(\kx^S, \cdot)$ takes as input a "public key" $k$, a set of ciphertexts $\arg_{\ct} = \{\ct_i\}$, and a plaintext argument $\arg_{p}$. It computes 
$$\sk \leftarrow \KX(k, \kx^S)$$
$$m_i \leftarrow \dec(\sk, \ct_i).$$ 
It outputs $\enc(\sk, f(\{m_i\}, \arg_p))$.
\end{definition}
\textbf{Remark}: Note we require $f$'s output to be constant length. The $\Eval$ oracle is stronger than the $\KXE$, but weaker than the $\KXD$ oracle described in \cref{sec:IND-CCPKA}.
\begin{definition}
\label{defn:AE-eval-security}
Let $N, R$ be polynomial in $\lambda$. Consider the two experiments defined in \cref{expr:AE-real-ideal-world}.

\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $\cA$ stores $1^{\lambda}, r, \{\kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, \ct, \arg_p \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}().$
        \item $\ct^{0}_r \leftarrow \Eval_f(\kx_i^S, \kx_j^P, \ct, \arg_p)$.
        \item $\cA$ stores $\ct^{0}_r$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $\cA$ stores $1^{\lambda}, r, \{\kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, m \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}()$.
        \item $ct^1_r \leftarrow \Sim(1^{\lambda}, \{(\kx_i^P, \kx_i^S)\}_{i \in [N]})$.
        \item $\cA$ stores $\ct^{1}_r$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\caption{Real and Ideal World Experiment for AE Scheme}
\label{expr:AE-real-ideal-world}
\end{figure}

Then we say the AE scheme is \textbf{Eval-Secure} if there exists a p.p.t simulator $\Sim$ such that for any polynomial-time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$ and any p.p.t adversary with oracle $\cA^O$, the real world experiment and the ideal world experiment are computationally indistinguishable.
\end{definition}
If we use symmetric key encryption with pre-distributed secret keys (assumed in \cite{angel2016unobservable}), then Eval-Security is implied by IK-CCA(\cite[Definition 1]{BBDP01keyprivate}). Since we do not have pre-distributed secret keys, we need to show that the key exchange step is secure as well. In \cref{sec:IND-CCPKA}, we define a new security requirement called IND-CCPKA  and show that Eval-Security is a corollary of IND-CCPKA security. We believe most existing AEAD system should be IND-CCPKA secure, though we are unable to rigorously demonstrate this.\todo{Well... Can we?}

\begin{definition}
\label{defn:AE-unforgability}
Consider the forging experiment described in \cref{expr:AE-forging}.

\begin{figure}[h!]
\begin{framed}
\textbf{Forging Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $i, j, \ct \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}(1^{\lambda}, \{\kx_i^P\}).$
\end{enumerate}
\end{framed}
\caption{Forging Experiment for AE Scheme}
\label{expr:AE-forging}
\end{figure}

Let $\ct_{\query, ij}$ be the set of output from queries to the Eval oracle of the form $\Eval_f(\kx_i^S, \kx_j^P, \cdot)$ or $\Eval_f(\kx_j^S, \kx_i^P, \cdot)$.

We say the AE scheme is \textbf{Eval-Unforgable} if there exists a p.p.t simulator $\Sim$ such that for any polynomial-time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$ and any p.p.t adversary with oracle $\cA^O$, we have
$$\PP(\dec(\KX(\kx_i^S, \kx_j^P), \ct) \neq \bot \land m \notin \ct_{\query, ij}) = \negl(\lambda).$$
\end{definition}
\todo{Does there exist problem with this definition? I'm fairly certain this gives what we want, but not 100\% sure this is actually correct.}

\textbf{Remark}: A corollary of Eval-Unforgability is the property that if $\{\kx_i^{P}, \kx_i^{S}\}(i = 1,2,3)$ are three randomly generated keypairs, and $\sk_{ij} = \KX(\kx_i^P, \kx_j^S)$, then for any message $m$, 
$$\Dec(\sk_{12}, \Enc(\sk_{13}, m)) = \bot$$ 
with probability $1 - \negl(\lambda)$. This property will be used in the correctness proof.
\subsubsection{PIR Scheme}
\label{subsec:PIR}
Central to our application is the Private Information Retrieval(PIR) scheme. It consists of three efficient algorithms
\begin{itemize}
    \item $\query(1^{\lambda}, i) \to (\ct, \sk)$.
    \item $\answer^{\DB}(1^{\lambda}, \ct) \to a$.
    \item $\dec(1^{\lambda}, \sk, a) \to x_i$.
\end{itemize}
% \arvid{Another PIR syntax, which I believe might be more standard?}
% \begin{itemize}
%     \item $\query_n(1^{\lambda}, i) \to (q, \mathsf{st})$.
%     \item $\answer_n(1^{\lambda}, D, q) \to a$.
%     \item $\dec_n(1^{\lambda}, \mathsf{st}, a) \to d$.
% \end{itemize}
% Nevermind! We are recycling the secret key for the PIR queries, because generating the keys is computationally expensive, and it does not affect security (it just becomes slightly less clean)
where $\DB$ is a length $N$ database with int64 entries, and $N$ is a parameter bounded by some polynomial $N(\lambda)$. It must satisfy correctness and security as defined below.
\begin{definition}
\label{defn:PIR-correctness}
For any database $\DB$ of length $N$ with entries of length $L_{\pir}$, consider the experiment
\begin{enumerate}
    \item $(\ct, \sk) \leftarrow \query(1^{\lambda}, i)$.
    \item $a \leftarrow \answer^{\DB}(1^{\lambda}, \ct)$.
    \item $x_i \leftarrow \dec(1^{\lambda}, \sk, a)$.
\end{enumerate}
We say the PIR scheme is \textbf{correct} if $x_i = DB[i]$ with probability $1$.
\end{definition}
\begin{definition}
\label{defn:PIR-SIM-security}
Let $n, R$ be polynomially bounded in $\lambda$. Consider the experiments in \cref{expr:pir-real-ideal-world}. We say the PIR scheme is \textbf{SIM-Secure} if there exists a p.p.t simulator $\Sim$ such that for any stated p.p.t adversary $\cA$, the view of $\cA$ under the real world experiment and the ideal world experiment are computationally indistinguishable. 

\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i_r \leftarrow \cA(1^{\lambda}, n)$.
        \item $\ct_r^0, \sk \leftarrow \query(1^{\lambda}, i_r)$.
        \item $\cA$ stores $\ct_r^0$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i_r \leftarrow \cA(1^{\lambda}, n)$.
        \item $\ct_r^1, \sk \leftarrow \Sim(1^{\lambda}, n)$.
        \item $\cA$ stores $\ct_r^1$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\caption{Real and Ideal World Experiment for PIR Scheme}
\label{expr:pir-real-ideal-world}
\end{figure}
\end{definition}
For our implementation, we use libsodium's key exchange functionality as the $\gen$ and $\KX$ functions, and libsodium's secret key AEAD for the $\enc$ and $\dec$ functions(\cite{libsodium}). We conjecture that this AE scheme satisfies IND-CCPKA security as in \cref{defn:AE-CCPKA}, thus satisfies \cref{defn:AE-eval-security}. We use Addra's FastPIR as the PIR protocol. The definition, correctness, and security proof of FastPIR can be found in \cite[Section 4]{ahmad2021addra} and in more detail \cite{angel2018thesis}.

Throughout the rest of the document, we denote the AE scheme $\Pi_{\ae}$, and the PIR scheme $\Pi_{\pir}$.
\subsection{Messages, Sequence numbers, ACKs}
Our integrity definition \cref{defn:messaging-integrity} requires protection against replay attacks. In this section, we describe how our system adopts TCP's Acknowledgement system to offer such protection.

Each client $i$ labels all messages to be sent to another client $j$ with a sequence number. In the order client $i$ receives $\send$ inputs to client $j$, client $i$ label the messages with sequence number $1,2,\cdots$. The client will transmit the labeled message\footnote{Called chunk in the implementation.} $\msg^{lb} = (k, \msg)$, where $k$ is the sequence number and $\msg$ is the actual message. 

Critical to both consistent prefix and eventual consistency is the ACK messages. An ACK message is a special type of messages denoted $\ACK(k)$, encoding a single integer $k$.\footnote{In our implementation, the ACK message is slightly more complicated to take chunking into account.}. When client $j$ sends $\ACK(k)$ to client $i$, it means ``I have read all messages up to message $k$ from you". As we will soon define rigorously, user $i$ will keep broadcasting message $k$ until user $j$ sends $\ACK(k)$, in which case they begin broadcasting message $k + 1$. 

To prevent replay attack, we ensure any ACK message is distinct from any labeled messages generated from user input.\footnote{In our implementation, ACKs and Chunks use different protobuf structs to guarantee this.}

We finish by detailing a subtlety on the length of messages. Let $L_{\msglb}$ denote the length of a labeled message $\msg^lb$, and let $L_{\ct}$ be the length of a ciphertext generated by encoding $\msg^{lb}$ with $\Pi_{\ae}.\enc$. While the input messages have length $L_{\msg}$, the messages client sent to the server have length $L_{\ct}$. We set parameter $L_{\ae} = L_{\msglb}$ in the AE scheme, and $L_{\pir} = L_{\ct}$ in the PIR scheme.
\subsection{Potential Security Vulnerability}
\label{subsec:security-vulnerable}
\todo{Move this elsewhere}.

In this section, we describe several previously unobserved security vulnerabilities we discovered while writing this document. These vulnerabilities show that even with a secure PIR implementation, the security of the whole system is not straightforward.

\textbf{The Impersonation Attack} The first new attack vector is the trust establishment system. Due to a lack of central authorities, our system uses the registration information $\reg$ as the unique identifier of a client / user. The registration information is a tuple $\reg = (i, \kx^P)$ containing the index $i$ of the client in the PIR database, and the key exchange public key $\kx^P$ of the client. This information is intended to be posted on the client / user's social media, so that others can verify that the registration info indeed belongs to the person.

Suppose user $A, B$ are friends, and their registration informations are $\reg_A = (i_A, \kx^P_A)$ and $\reg_B = (i_B, \kx^P_B)$ respectively. Then a malicious user $C$ can declare on their webpage that their registration information is $\reg_C = (i_C, \kx^P_B)$. If user $A$ establishes trust with user $C$, then user $B$ will ``overhear" all conversations between user $A$ and user $C$, since the way $B$ decides if a message from $A$ is meant for them is by decrypting user $A$'s ciphertext with their shared public key $\sk_{AB}$. By letting $\sk_{AC} = \sk_{AB}$, user $C$ compromised the integrity of user $A$ and $B$'s conversation.

There are many ways to resolve this issue. The most straightforward solution is for users to sign their registration information with their secret key. However, this will make the registration information too long to be put in e.g. a twitter profile. Another solution is to label each message with their intended recipient; we are planning to incorporate this solution ASAP.

\textbf{The PIR Request Replay Attack} Another new attack vector is the ACK system. While the ACK messages are essential to ensure our consistency model, it introduces a way for an adversarial server to get ``feedback" on their malicious responses to the client. We describe one way to exploit this.

Most PIR schemes nowadays use an underlying homomorphic public key cryptosystem, and generating the public-private keypair is expensive. For the sake of performance, some MPM systems such as Addra generate a keypair $(\pk_{\pir}, \sk_{\pir})$ once for each client and use them in all PIR queries $\ct = \query(1^{\lambda}, \sk_{\pir}, i)$. This design creates a serious security hole in many messaging system, as we detail below.

Suppose at time $T_0$, honest user $A$ sends a PIR request $\ct$ to the server. Malicious user $C$, colluding with the server, wishes to know if $\ct$ is a query to honest user $B$'s mailbox at index $i_B$. The attack depends on three requirements.
\begin{itemize}
    \item User $A$ is going to have a conversation with a malicious user $C$ at a future time $T_1 > T_0$. 
    \item Honest user $A$ does not switch PIR keypair between time $T_0$ and $T_1$.
    \item Honest user $A$ will provide "feedback" $f(m)$ to user $C$'s messages $m$. This could be an $\ACK$ message in our system, or simply a verbal response to $C$'s message.  
\end{itemize}

The attack goes as follows. At time $T_0$, the server stores $\ct$, and continue to serve $A$ honestly until time $T_1$. During $A$ and $C$'s conversation, the server formulates a response $\resp = \answer^{DB'}(1^{\lambda}, \ct)$, where $DB'[i_B]$ is a valid message from $C$ to $A$, and $DB'[i] = 0$ for any $i \neq i_B$. If $\ct$ is a query to $i_B$, $A$ will receive the message from $C$, and send a feedback to $C$. Otherwise, $A$ will not receive a message from $C$ and not send an ACK to $C$. Therefore, $C$ can observe $A$'s feedback and learn if $\ct$ is a query to $i_B$ or not.

This attack can be prevented by changing the PIR keypair each round, which is ok for Anysphere because of our low clientside computation . However, it provides evidence that a secure PIR system does not guarantee metadata security of the whole system.
\subsection{The Anysphere Core Protocol}
\todo{I'm going to stick to our actual implementation as closely as possible, please point out anything that doesn't agree with the current protocol, greatly appreciate it.}

We first recall some notations.
\begin{itemize}
    \item $\lambda$ is the security parameter.
    \item $N$ is the number of users.
    \item $T$ is the number of timesteps our protocol is run.
    \item $L_{\msg}$ is the length of each message we send.
    \item $\Pi_{\ae}$ is an AE scheme satisfying \cref{defn:AE-correctness}, \cref{defn:AE-eval-security} and \cref{defn:AE-unforgability}.
    \item $\Pi_{\pir}$ is a PIR scheme satisfying \cref{defn:PIR-correctness} and \cref{defn:PIR-SIM-security}.
\end{itemize}
We can now formally define Anysphere's core protocol.
\begin{definition}
\label{defn:asphr-code}
The Anysphere messaging system $\Pi_{\asphr}$ implements the methods of \cref{defn:messaging-scheme} following the pseudocode below. In each method, the caller stores all inputs for future use.
\vspace{10pt}

$\mathbf{\Pi_{\asphr}.C.\mathsf{Register}}(1^{\lambda}, i, N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item Initialize empty map $\frienddb$. The map take registration info as keys, and the following fields as values.    \footnote{These fields are currently implicit. They are made explicit here for simplicity}
    \begin{itemize}
        \item $\mathsf{sk}$, the secret key.
        \item $\seqs$, the sequence number of the current message being broadcasted to the friend.
        \item $\seqe$, the highest sequence number ever assigned to messages to the friend.
        \item $\seqr$, the highest sequence number received from the friends.
    \end{itemize}

    \arvid{a bit confused between seqend and seqstart...}
    \stzh{in other words, the inbox contains messages in [seqstart, seqend].}
    \item Initialize empty maps $\inb, \outb$. The maps take registration info as keys, and arrays of messages as values.\footnote{They are named Friend, Inbox, Outbox in our code. Our code is slightly more complicated to support features like sending to multiple friends and chunking.}
    \item Set a transmission schedule $T_{\trans}$. The user can customize this parameter. We assume $T_{\trans}$ is upper bounded by a constant $T_{\trans}^U$.
    \item $(\kx^P, \kx^S) \leftarrow \Pi_{\ae}.\gen(1^{\lambda})$. 
    \item Return $\reg = (i, \kx^P)$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\mathsf{InitServer}}(1^{\lambda}, N)$.
\vspace{5pt}
\hrule
\vspace{5pt}
Initialize arrays $\msgdb, \ackdb$ of length $N$ with entries of length $L_{\ct}$. Fill them with random strings.

\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\Userinput}(t, \cI)$
\vspace{5pt}
\hrule
\vspace{5pt}
This method runs in two phases. Phase 1 handles the user input $\cI$, and phase 2 formulates the server request.

Phase 1: 

If $\cI = \emptyset$, do nothing. 

If $\cI = \send(\reg, \msg)$, 

\begin{enumerate}
    \item Check that $\msg$ has length $L_{\msg}$. If not, skip to Phase 2.
    \item Check that $\reg$ is in $\frienddb$. If not, skip to Phase 2.
    \item If $\reg$ is the registration of $C_i$ itself, append $\msg$ to $\inb[\reg]$, and skip to Phase 2. \footnote{Skipping this step breaks consistent prefix.}
    \item Add $1$ to $\frienddb[\reg].\seqe$. 
    \item Push $\msg^{lb} = (\frienddb[\reg].\seqe, \msg)$ to $\outb[\reg]$.
\end{enumerate}

If $\cI = \trust(\reg)$.
\begin{enumerate}
    \item Check if $\reg$ is in $\frienddb$. If so, skip to Phase 2.
    \item $(i, \kx_f^P) \leftarrow \reg$.
    \item $sk \leftarrow \Pi_{\ae}.\KX(\kx_f^P, \kx^S).$
    \item $\frienddb[\reg] \leftarrow \{\sk: sk,  \seqs: 1, \seqe: 0, \seqr: 0\}$.
\end{enumerate}

Phase 2:
\begin{enumerate}
    \item If $t$ is not divisible by $T_{\trans}$, return $\emptyset$.
    \item Let $\{\reg_1, \cdots, \reg_k\}$ be the keys of $\frienddb$, with $k\leq B$. Construct $S = [\reg_1,\cdots, \reg_k, \reg, \cdots, \reg]$, where we add $B - k$ copies of $\reg$, our own registration info. Sample $\reg_s, \reg_r$ uniformly and independently at random from $S$. \arvid{this is not what we currently do. maybe we should. we should make a decision on the CF attack here and what is acceptable. i think my favorite idea is leaking a rounded version of the number of friends, or something like that. however, the way the code works now where we pick a random friend among the friends that we have outgoing messages to is quite nice because it means that messages will get delivered much faster (especially once we implement PIR batch retrieval)...}
    \item Let $\msg$ be the (labeled) message with sequence number $\frienddb[\reg_s].\seqs$ in $\outb[\reg_s]$. If $\outb[\reg_s]$ is empty, let $\msg \leftarrow (-1, 0^{L_{\msg}})$.
    \item $\sk \leftarrow \frienddb[\reg_s].\sk$. If $\reg_s$ does not exist in $\frienddb$, randomly generate a secret key $\_, \sk \leftarrow \Pi_{\ae}.\gen(1^{\lambda}).$
    \item $\seqr \leftarrow \frienddb[\reg_s].\seqr$.
    \item Encrypt Messages with $\sk$.
    \begin{itemize}
        \item $\ct_{\msg} \leftarrow \Pi_{\ae}.\enc(\sk, \msg).$
        \item $\ct_{\ack} \leftarrow \Pi_{\ae}.\enc(\sk, \ACK(\seqr))$. \arvid{should we talk about the ACK db here, and the fact that we always send all ACKs to everyone? maybe we shouldn't do that anymore... it was necessary for prioritization, but if we don't want to do prioritization then maybe we shouldn't do it anymore}
    \end{itemize}
    \item Let $\reg_r = (i_r, \_)$. Formulate a PIR request for index $i_r$. %\arvid{this $r$ is not the same as the $r$ in $\reg_r$? maybe this should be $i_r$ or something}
    \begin{itemize}
        \item $\ct_{\query}, \sk_{\pir} \leftarrow \Pi_{\pir}.\query(1^{\lambda}, i_r).$
    \end{itemize}
    \item return $\req = (\ct_{\msg}, \ct_{\ack}, \ct_{\query})$.
    \item Remember $\reg_r$ and $\sk_{\pir}$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\Clientrpc}(t, \{\req_i\}_{i = 1}^N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\item for $i$ from $1$ to $N$
\arvid{do we want to deal with authentication tokens here? only if we modify the security definition to include potentially malicious clients, which I'm not sure is worth the trouble...}
\stzh{I vote for no Authentication token for now.}
\begin{enumerate}
    \item If $\req_i = \emptyset$, let $\resp_i = \emptyset$, and continue to next $i$. 
    \item Parse $\req_i = (\ct_{\msg}, \ct_{\ack}, \pk_{\pir}, \ct_{\query})$.
    \item $\msgdb[i] \leftarrow \ct_{\msg}, \ackdb[i] \leftarrow \ct_{\ack}$.
    \item $a_{\msg} \leftarrow \Pi_{\pir}.\answer^{\msgdb}(1^{\lambda}, \ct_{\query}).$
    \item $a_{\ack} \leftarrow \Pi_{\pir}.\answer^{\ackdb}(1^{\lambda}, \ct_{\query}).$
    \item $\resp_i \leftarrow (a_{\msg}, a_{\ack}).$
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\Serverrpc}(t, \resp)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item If $\resp = \emptyset$, return.
    \item Parse $\resp = (a_{\msg}, a_{\ack})$. Let $\reg_r, \sk_{\pir}$ be defined in the last call to $\Pi_{\asphr}.C.\Userinput$.
    \item $\ct_{\msg} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\msg}).$
    \item $\ct_{\ack} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\ack}).$
    \item $\sk_{\ae} \leftarrow \frienddb[\reg_r].\sk$.
    \item Decipher the message.
    \begin{enumerate}
        \item $\msg^{lb} \leftarrow \Pi_{\ae}.\Dec(\sk_{\ae}, \ct_{\msg})$.
        \item If $\msg^{lb} = \bot$ or $\msg^{lb}[0]$ is not $\frienddb[\reg_r].\seqr + 1$, skip the next two steps.
        \item Add $1$ to $\frienddb[\reg_r].\seqr$. 
        \item Let $\msg$ be $\msg^{lb}[1]$. Push $\msg$ to $\inb[\reg_r]$.
    \end{enumerate}
    \item Decipher the ACK.
    \begin{enumerate}
        \item $\ack \leftarrow \Pi_{\ae}.\Dec(1^{\lambda}, \sk_{\ae}, \ct_{\ack})$.
        \item If $\ack = \bot$ or $\ack$ is not the form $\ACK(k)$ for some $k$, return.
        \item Let $\ack = \ACK(k)$. If $k < \frienddb[\reg_r].\seqs$, return.
        \item $\frienddb[\reg_r].\seqs \leftarrow k + 1$. Remove the message with sequence number $k$ from $\outb[\reg_r]$.
    \end{enumerate}
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{GetView}}()$
\vspace{5pt}
\hrule
\vspace{5pt}
Let $\cF$ be the set of keys in $\frienddb$. Let $\cM$ be the set $\{(\reg_r, \msg): \msg \in \inb[\reg_r]\}$. Return $(\cF, \cM)$.

\end{definition}