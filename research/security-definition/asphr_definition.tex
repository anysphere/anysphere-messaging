\newcommand{\frienddb}{\mathsf{frdb}}
\newcommand{\seqs}{\mathsf{seqstart}}
\newcommand{\seqe}{\mathsf{seqend}}
\newcommand{\seqr}{\mathsf{seqreceived}}
\newcommand{\inb}{\mathsf{in}}
\newcommand{\outb}{\mathsf{out}}
\newcommand{\msgdb}{\mathsf{msgdb}}
\newcommand{\msglb}{\mathsf{msglb}}
\newcommand{\ackdb}{\mathsf{ackdb}}
\newcommand{\trans}{\mathsf{trans}}
\newcommand{\ACK}{\mathsf{ACK}}
\newcommand{\ack}{\mathsf{ack}}
\newcommand{\KXE}{\mathsf{KXE}}
\newcommand{\KXD}{\mathsf{KXD}}
\newcommand{\KX}{\mathsf{KX}}
\section{Definition of Anysphere}
In this section, we define the Anysphere core protocol described in our whitepaper. We rigorously define how our core protocol is able to handle multiple contacts, run asynchronous rounds. In the next section, we will prove that our core protocol maintains correctness and security.
\subsection{A weaker Security Definition}
Unfortunately, Anysphere does not support the strongest security notion described above, due to CF attacks. For the threat model in our whitepaper, we assume that no friends are compromised. We now define a weaker security notion with this additional hypothesis.

\arvid{Another path to explore here would be to create a new leak function, say LeakCF, which contains the exact information leaked for the CF attack. For example, one potentially useful leak function would be one that contains the current number of friends, or perhaps the number of friends but rounded to the nearest 10. In the worst case (such as our current prioritization case), we would leak the timing that a message actually gets sent to the server, which might be very hard to model here... Hmmmm}

\begin{definition}[SIM-secure with no compromised friends and bounded friends]
We say that a set of input $\{\cI_{i, t}\}_{i \in \cH, t \in [T]}$ satisfy \textbf{no compromised friends} if for any $i \in \cH, j \in \cK$ and $t \in [T]$, we have
$$\trust(\reg_j) \neq \cI_{i, t}.$$
We say that a set of input $\{\cI_{i, t}\}_{i \in \cH, t \in [T]}$ satisfy \textbf{$B$-bounded friends} if for any $i \in \cH$, the set
$$\{\reg: \exists t, \trust(\reg) = \cI_{i, t}\}$$
has cardinality at most $B$.

We say a messaging scheme is correct with $B$-bounded friends iff for any parameters $(\lambda, N, T, \{\cI_{i, t}\})$ of the honest server experiment, if $\{\cI_{i, t}\}$ satisfy $B$-bounded friends, then the scheme produces the correct views.

We say a messaging scheme is SIM-secure with no compromised friends / $B$-bounded friends iff for any polynomial upper bounds on $N$ and $T$, there exists a p.p.t simulator $\Sim$ such that for any p.p.t adversary $\cA$, the view of $\cA$ is indistinguishable in $\mathsf{Real}^{\cA}(1^{\lambda})$ and $\mathsf{Ideal}^{\cA, \mathsf{\Sim}}(1^{\lambda})$, provided that the input set $\{\cI_{i, t}\}_{i \in \cH, t \in [T]}$ satisfies no compromised friends / $B$-bounded friends.
\end{definition}
\textbf{Remark}: It is possible to bypass CF attacks under either $B$-bounded friends or no compromised friends model. We'll assume the $B$-bounded friends for now.

Currently we have $B = 2$.

We now explain the construction of Anysphere. 
\subsection{Cryptography Primitives}
Anysphere relies on two crypto primitives: a symmetric key AE, and a PIR scheme. We outline formal simulator-based definition of the two.
\subsubsection{Key Private IND-CPA symmetric key AE scheme}
\arvid{we probably want IND-CCA to guarantee integrity?}
\stzh{Resolved, adds EUF-CMA assumption below.}
\todo{Rename this. IK-CPA is far from enough.}
A key-private IND-CPA symmetric key AE (Authenticated Encryption) scheme is a quadruple of algorithms $(\gen, \KX, \enc, \dec)$ with specifications
\begin{itemize}
    \item $\gen(1^{\lambda}) \to (kx^P, kx^S)$,
    \item $\KX(1^{\lambda}, kx_A^P, kx_B^S) \to sk_{AB},$
    \item $\enc(sk_{AB}, m) \to ct,$
    \item $\dec(sk_{BA}, ct) \to m.$
\end{itemize}
such that 
\begin{definition}[Correctness]
\label{defn:KX-Correctness}
If we let
\begin{enumerate}
    \item $(kx^P_A, kx_A^S), (kx^P_B, kx_B^S)  \leftarrow \gen(1^{\lambda}).$
    \item $sk_{AB} \leftarrow \KX(1^{\lambda}, kx_A^P, kx_B^S), sk_{BA} \leftarrow \KX(1^{\lambda}, kx_B^P, kx_A^S)$
\end{enumerate}
then $sk_{AB} = sk_{BA}$ with probability $1$. \todo{This simplifies the security definition below. Otherwise, we need to give adversary power to call $\Enc$ on $\sk_{ij}$, where $h$ is uncompromised.} For any plaintext $m$ of a fixed length $L$, we have
$$\dec(sk_{BA}, \enc(sk_{AB}, m)) = m.$$
\todo{I think there is a subtlety here: The line below is not covered by EUF-CMA.}
Furthermore, for any secret key $sk' \neq sk_{AB}$, we have
$$\dec(sk_{BA}, \enc(sk', m)) = \bot.$$

\end{definition}
\todo{The following definitions about security has not existed in literature(as communicated by Prof. Angel). Do we want a proof that libsodium satisfies this? The "Private Signaling" paper seems to contain a related definition?}

\todo{I need to find a ``no backdoor" guarantee here for the KX algorithm. Basically, an adversary should be able to challenge KX with arbitrary public key(not necessarily coming from Gen()), and not leak information. the key exchange oracle is my take on this. Another approach involves ZK proofs, but might be expensive to implement.}

\todo{Update: see Section 5 for a formal description of this guarantee, which I call IND-CCPKA.}

To formally define the security notion our system is required to satisfy, we first define some oracles.

\textbf{Convention.} Given an oracle $O(x, \cdot)$ and a series $\{x_i\}_i$, define $O(\{x_i\}_i, \cdot)$ as the oracle whose input takes an extra argument $j$ and outputs $O(\{x_i\}_i, j, \cdot) = O(x_j, \cdot)$.

\textbf{Convention.} When we say two experiments are indistinguishable, we mean the view of the adversary in the two experiments are indistinguishable. The view of the adversary consists of all inputs, outputs, and internal randomness of the adversary.

\begin{definition}
The key-exchange-and-encrypt(KXE) oracle $\KXE(kx^S, \cdot)$ takes as input a public key $kx_m^P$ and a message $m$, and computes
$$\sk \leftarrow \KX(kx^S, kx_m^P),$$
$$\ct \leftarrow \enc(\sk, m).$$
It outputs $\ct$.

The key-exchange-and-decrypt(KXD) oracle $\KXD(kx^S, \cdot)$ takes as input a public key $kx_m^P$ and a ciphertext $\ct$, and computes
$$\sk \leftarrow \KX(kx^S, kx_m^P),$$
$$m \leftarrow \dec(\sk, \ct).$$
It outputs $m$.
\end{definition}
\begin{definition}[ACK Oracle]
\label{defn:ack-oracle}
Given a key exchange secret key $kx^S$, and a polynomial time computable function $\ACK: \NN \to \Sigma^*$, the ACK oracle $O_\ACK(kx^S, f, \cdot)$ takes as input a ``fake key" $k$ and a set of ciphertexts $\ct_i$, computes $m_i = \KXD(kx^S, k, \ct_i)$ for each $i$. Let $\ell$ be the number of $m_i$ that are not $\bot$. The oracle output $\enc(sk, \ACK(\ell))$.
\end{definition}
\begin{definition}
\label{defn:sym-security}
Let $N, R$ be polynomial in $\lambda$. Consider two experiments.
\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(kx_i^P, kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item For $(i, j)$ in $[N]^2$, $sk_{ij} \leftarrow \KX(1^{\lambda}, kx_i^P, kx_j^S)$.
    \item $\cA$ stores $1^{\lambda}, r, \{kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, m \leftarrow \cA^{\KXE(\{kx_i^S\}, \cdot), O_{\ACK}(\{kx_i^S\}, \ACK, \cdot)}().$
        \item $ct^{0}_r \leftarrow \enc(sk_{ij}, m)$.
        \item $\cA$ stores $ct^{0}_r$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(kx_i^P, kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item For $(i, j)$ in $[N]^2$, $sk_{ij} \leftarrow \KX(1^{\lambda}, kx_i^P, kx_j^S)$.
    \item $\cA$ stores $1^{\lambda}, r, \{kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, m \leftarrow \cA^{\KXE(\{kx_i^S\}, \cdot), O_{\ACK}(\{kx_i^S\}, \ACK, \cdot)}()$.
        \item $ct^1_r \leftarrow \Sim(1^{\lambda}, \{(kx_i^P, kx_i^S)\}_{i \in [N]})$.
        \item $\cA$ stores $ct^{1}_r$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\end{figure}

Then we say the encryption scheme is key-private IND-CPA if there exists a p.p.t simulator $\Sim$ such that for any polynomial computable function $\ACK: \NN \to \Sigma^*$, any p.p.t adversary with oracle $\cA^O$, the real world experiment and the ideal world experiment are computationally indistinguishable.
\end{definition}
\begin{definition}[EUF-CMA Authentication]
Let $kx^P_A, kx^P_B, \sk_{AB}, \sk_{BA}$ be the same as \cref{defn:KX-Correctness}. For any p.p.t. adversary $\cA^O$ with access to oracle $O$, if
$$m \leftarrow \cA^{\Enc(\sk_{AB}, \cdot), \Enc(\sk_{BA}, \cdot)}(1^{\lambda}, kx^P_A, kx^P_B)$$
then 
$$\PP(m \notin Q, \Dec(\sk_{BA}, m) \neq \bot) = \negl(\lambda),$$
where $Q$ is the set of messages that $\cA$ queried to the oracle.
\end{definition}

\subsubsection{PIR Protocol}
Central to our application is the Private Information Retrieval(PIR) Protocol. It consists of four efficient algorithms
\begin{itemize}
    \item $\gen(1^{\lambda}, n) \to (pk, sk)$.
    \item $\query(1^{\lambda}, sk, i) \to ct$.
    \item $\answer^{DB}(1^{\lambda}, pk, ct) \to a$.
    \item $\dec(1^{\lambda}, sk, a) \to x_i$.
\end{itemize}
% \arvid{Another PIR syntax, which I believe might be more standard?}
% \begin{itemize}
%     \item $\query_n(1^{\lambda}, i) \to (q, \mathsf{st})$.
%     \item $\answer_n(1^{\lambda}, D, q) \to a$.
%     \item $\dec_n(1^{\lambda}, \mathsf{st}, a) \to d$.
% \end{itemize}
% Nevermind! We are recycling the secret key for the PIR queries, because generating the keys is computationally expensive, and it does not affect security (it just becomes slightly less clean)
where $D$ is a length $n$ database with int64 entries, and $n$ is upper bounded by some polynomial $n(\lambda)$. It must satisfy
\begin{definition}[Correctness]
For any database $DB$ of length $n$ with int64 entries, and any message $ct$ of length $L_{\msg}$, if we run
\begin{enumerate}
    \item $(pk, sk) \leftarrow \gen(1^{\lambda}, n)$.
    \item $ct \leftarrow \query(1^{\lambda}, sk, i)$.
    \item $a \leftarrow \answer^{DB}(1^{\lambda}, pk, ct)$.
    \item $x_i \leftarrow \dec(1^{\lambda}, sk, a)$.
\end{enumerate}
then $x_i = DB[i]$.
\end{definition}
\begin{definition}[SIM Security]
\label{defn:pir-security}
Let $n, R$ be polynomially bounded in $\lambda$.  onsider the following two experiments. Then we say the PIR scheme is \textbf{secure} if there exists a p.p.t simulator $\Sim$ such that stated p.p.t adversary $\cA$, the view of $\cA$ under the real world experiment and the ideal world experiment are computationally indistinguishable. 
\todo{This definition is equivalent to https://eprint.iacr.org/2022/081.pdf, Experiment 2.2. The definition over there is IND. May want to add a note here.}
\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item $(pk, sk) \leftarrow \gen(1^{\lambda}, n).$
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i \leftarrow \cA(1^{\lambda}, n, pk, \{ct_s^0\}_{s < r})$.
        \item $ct_r^0 \leftarrow \query(1^{\lambda}, sk, i)$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item $(pk, sk) \leftarrow \gen(1^{\lambda}, n).$
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i \leftarrow \cA(1^{\lambda}, n, pk, \{ct_s^1\}_{s < r}))$.
        \item $ct_r^1 \leftarrow \Sim(1^{\lambda}, sk, n)$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\end{figure}
\end{definition}
For our implementation, we use libsodium's key exchange functionality for the $\KX$ function, then libsodium's secret key AEAD for the $\enc$ and $\dec$ functions. This provides a Key Private IND-CPA symmetric key encryption scheme. We use Addra as the PIR protocol.
\subsection{Messages, Sequence numbers, ACK}
\todo{It turns out the ACK system creates a significant security subtlety.}
To guarantee the consistent prefix property, each client $i$ labels all messages to be sent to another client $j$ with a sequence number. In the order client $i$ receives $\send$ inputs to client $j$, client $i$ label the messages with sequence number $1,2,\cdots$. The client will transmit the labeled message\footnote{Called chunk in the code.} $\msg^{lb} = (k, \msg)$, where $k$ is the sequence number and $\msg$ is the actual message. 

Critical to both consistent prefix and eventual consistency is the ACK messages. An ACK message is a special type of messages denoted $\ACK(k)$.\todo{In the whitepaper an additional chunk number is used. Since this definition does not use chunking, I'll ignore it}. When client $j$ sends $\ACK(k)$ to client $i$, it means ``I have read all messages up to message $k$ from you". As we will soon define rigorously, user $i$ will keep broadcasting message $k$ until user $j$ sends $\ACK(k)$, in which case they begin broadcasting message $k + 1$. 

To prevent replay attack, we encode ACK messages differently from actual messages sent between users\footnote{In the code, this is guaranteed as ACKs and Chunks use different protobuf structs.}. Any ACK message is distinct from any labeled messages generated from user input.

Let $L_{\msglb}$ denote the length of the labeled message, and let $L_{\ct}$ be the length of the ciphertext generated by encoding $\msg^{lb}$ with $\Pi_{\sym}.\enc$. While the input messages have length $L_{\msg}$, the messages client sent to the server have length $L_{\ct}$. We will take $L = L_{\ct}$ in the PIR scheme.
\subsection{The Anysphere Core Protocol}
\todo{I'm going to stick to our actual implementation as closely as possible, please point out anything that doesn't agree with the current protocol, greatly appreciate it.}
Let's first recap and summarize what we have defined so far. Recall that
\begin{enumerate}
    \item $\lambda$ is the security parameter.
    \item $N$ is the number of users.
    \item $T$ is the number of timesteps our protocol is run.
    \item $L_{\msg}$ is the length of each message we send.
    \item We use a key-private IND-CPA symmetric key AE scheme $\Pi_{\sym}$.
    \item We use a PIR protocol $\Pi_{\pir}$.
\end{enumerate}
We can now formally define Anysphere's core protocol.
\begin{definition}[The Anysphere Core Protocol]
Our protocol, $\Pi_{\asphr}$, implements the methods of \cref{def:messaging-scheme} as below. In each method, the caller stores all inputs for future use.
\vspace{10pt}

$\mathbf{\Pi_{\asphr}.C.\mathsf{Register}}(1^{\lambda}, i, N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item Initialize empty map $\frienddb$. The map take registration info as keys, and the following fields as values.
    \begin{itemize}
        \item $\mathsf{sk}$, the secret key.
        \item $\seqs$, the sequence number of the current message being broadcasted to the friend.
        \item $\seqe$, the highest sequence number ever assigned to the friend.
        \item $\seqr$, the highest sequence number received from the friends.
    \end{itemize}
    \todo{These fields are currently implicit. Included for simplicity}
    \arvid{a bit confused between seqend and seqstart...}
    \stzh{in other words, the inbox contains messages in [seqstart, seqend].}
    \item Initialize empty maps $\inb, \outb$. The maps take registration info as keys, and arrays of messages as values.\footnote{They are named Friend, Inbox, Outbox in our code. Our code is slightly more complicated to support features like sending to multiple friends and chunking.}
    \item Set a transmission schedule $T_{\trans}$. The user can customize this parameter. We assume $T_{\trans}$ is upper bounded by a constant $T_{\trans}^U$.
    \item $(kx^P, kx^S) \leftarrow \gen(1^{\lambda})$. 
    \item Initialize PIR Keys. $(\pk_{\pir}, \sk_{\pir}) \leftarrow \Pi_{\pir}.\gen(1^{\lambda}, N).$
    \item Return $\reg \leftarrow (i, kx^P)$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\mathsf{InitServer}}(1^{\lambda}, N)$.
\vspace{5pt}
\hrule
\vspace{5pt}
Initialize arrays $\msgdb, \ackdb$ of length $N$. Fill them with random strings.

\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{Input}}(t, \cI)$
\vspace{5pt}
\hrule
\vspace{5pt}
This method runs in two phases. Phase 1 handles the user input $\cI$, and phase 2 formulates the server request.

Phase 1: 

If $\cI = \emptyset$, do nothing. 

If $\cI = \send(\reg, \msg)$, 

\begin{enumerate}
    \item Check that $\msg$ has length $L_{\msg}$. If not, skip to Phase 2.
    \item Check that $\reg$ is in $\frienddb$. If not, skip to Phase 2.
    \item If $\reg$ is the registration of $C_i$ itself, append $\msg$ to $\inb[\reg]$, and skip to Phase 2. \footnote{Skipping this step breaks consistent prefix.}
    \item Add $1$ to $\frienddb[\reg].\seqe$. 
    \item Push $\msg^{lb} = (\frienddb[\reg].\seqe, \msg)$ to $\outb[\reg]$.
\end{enumerate}

If $\cI = \trust(\reg)$.
\begin{enumerate}
    \item Check if $\reg$ is in $\frienddb$. If so, skip to Phase 2.
    \item $(i, kx_f^P) \leftarrow \reg$.
    \item $sk \leftarrow \Pi_{\sym}.\KX(1^{\lambda}, kx_f^P, kx^S).$
    \item $\frienddb[\reg] \leftarrow \{\sk: sk,  \seqs: 1, \seqe: 0, \seqr: 0\}$.
\end{enumerate}

Phase 2:
\begin{enumerate}
    \item If $t$ is not divisible by $T_{\trans}$, return $\emptyset$.
    \item Let $\{\reg_1, \cdots, \reg_k\}$ be the keys of $\frienddb$, with $k\leq B$. Construct $S = [\reg_1,\cdots, \reg_k, \reg, \cdots, \reg]$, where we add $B - k$ copies of $\reg$, our own registration info. Sample $\reg_s, \reg_r$ uniformly and independently at random from $S$. \arvid{this is not what we currently do. maybe we should. we should make a decision on the CF attack here and what is acceptable. i think my favorite idea is leaking a rounded version of the number of friends, or something like that. however, the way the code works now where we pick a random friend among the friends that we have outgoing messages to is quite nice because it means that messages will get delivered much faster (especially once we implement PIR batch retrieval)...}
    \item Let $\msg$ be the (labeled) message with sequence number $\frienddb[\reg_s].\seqs$ in $\outb[\reg_s]$. If $\outb[\reg_s]$ is empty, let $\msg \leftarrow (-1, 0^{L_{\msg}})$.
    \item $\sk \leftarrow \frienddb[\reg_s].\sk$. If $\reg_s$ does not exist in $\frienddb$, randomly generate a secret key $\_, \sk \leftarrow \Pi_{\sym}.\gen(1^{\lambda}).$
    \item $\seqr \leftarrow \frienddb[\reg_s].\seqr$.
    \item Encrypt Messages with $\sk$.
    \begin{itemize}
        \item $\ct_{\msg} \leftarrow \Pi_{\sym}.\enc(\sk, \msg).$
        \item $\ct_{\ack} \leftarrow \Pi_{\sym}.\enc(\sk, \ACK(\seqr))$. \arvid{should we talk about the ACK db here, and the fact that we always send all ACKs to everyone? maybe we shouldn't do that anymore... it was necessary for prioritization, but if we don't want to do prioritization then maybe we shouldn't do it anymore}
    \end{itemize}
    \item Let $\reg_r = (i_r, \_)$. Formulate a PIR request for index $i_r$. %\arvid{this $r$ is not the same as the $r$ in $\reg_r$? maybe this should be $i_r$ or something}
    \begin{itemize}
        \item $\ct_{\query} \leftarrow \Pi_{\pir}.\query(1^{\lambda}, \sk_{\pir}, i_r).$
    \end{itemize}
    \item return $\req = (\ct_{\msg}, \ct_{\ack}, \pk_{\pir}, \ct_{\query})$.
    \item Remember $\reg_r$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\mathsf{ClientRPC}}(t, \{\req_i\}_{i = 1}^N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\item for $i$ from $1$ to $N$
\arvid{do we want to deal with authentication tokens here? only if we modify the security definition to include potentially malicious clients, which I'm not sure is worth the trouble...}
\stzh{I vote for no Authentication token for now.}
\begin{enumerate}
    \item If $\req_i = \emptyset$, let $\resp_i = \emptyset$, and continue to next $i$. 
    \item Parse $\req_i = (\ct_{\msg}, \ct_{\ack}, \pk_{\pir}, \ct_{\query})$.
    \item $\msgdb[i] \leftarrow \ct_{\msg}, \ackdb[i] \leftarrow \ct_{\ack}$.
    \item $a_{\msg} \leftarrow \Pi_{\pir}.\answer^{\msgdb}(1^{\lambda}, \pk_{\pir}, \ct_{\query}).$
    \item $a_{\ack} \leftarrow \Pi_{\pir}.\answer^{\ackdb}(1^{\lambda}, \pk_{\pir}, \ct_{\query}).$
    \item $\resp_i \leftarrow (a_{\msg}, a_{\ack}).$
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{ServerRPC}}(t, \resp)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item If $\resp = \emptyset$, ignore.
    \item Parse $\resp = (a_{\msg}, a_{\ack})$. Let $\reg_r, \sk_{\pir}$ be defined in the last call to $\Pi_{\asphr}.C.\mathsf{Input}$.
    \item $\ct_{\msg} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\msg}).$
    \item $\ct_{\ack} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\ack}).$
    \item $\sk \leftarrow \frienddb[\reg_r].\sk$.
    \item Decipher the message.
    \begin{enumerate}
        \item $\msg^{lb} \leftarrow \Pi_{\sym}.\Dec(1^{\lambda}, \sk, \ct_{\msg})$.
        \item If $\msg^{lb} = \bot$ or $\msg^{lb}[0]$ is not $\frienddb[\reg_r].\seqr + 1$, ignore the message.
        \item Add $1$ to $\frienddb[\reg_r].\seqr$. 
        \item Let $\msg$ be $\msg^{lb}[1]$. Push $\msg$ to $\inb[\reg_r]$.
    \end{enumerate}
    \item Decipher the ACK.
    \begin{enumerate}
        \item $\ack \leftarrow \Pi_{\sym}.\Dec(1^{\lambda}, \sk, \ct_{\ack})$.
        \item If $\ack = \bot$ or $\ack$ is not the form $\ACK(k)$ for some $k$, ignore the ack.
        \item Let $\ack = \ACK(k)$. If $k < \frienddb[\reg_r].\seqs$, ignore the ack.
        \item $\frienddb[\reg_r].\seqs \leftarrow k + 1$. Remove the message with sequence number $k$ from $\outb[\reg_r]$.
    \end{enumerate}
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{GetView}}()$
\vspace{5pt}
\hrule
\vspace{5pt}
Let $\cF$ be the set of keys in $\frienddb$. Let $\cM$ be the set $\{(\reg_r, \msg): \msg \in \inb[\reg_r]\}$. Return $(\cF, \cM)$.

\end{definition}