\section{Definition of Anysphere}
\label{sec:asphr-defn}
In this section, we formally define the Anysphere core protocol described in our whitepaper \cite{whitepaper}. 
\subsection{Cryptography Primitives}
Anysphere relies on two cryptographical primitives: an authenticated encryption(AE) system, and a PIR scheme. We outline formal simulator-based security definitions of the two.

It turns out that our security definition of the PIR scheme is standard and well-documented in literature. However, existing security definitions on the AE system , including IND-CCA2 or even IK-CCA(\cite{BBDP01keyprivate}), are not sufficient. In this section, we introduce a security requirement, called Eval Security, that is sufficient to establish the security of our system.
\subsubsection{Authenticated Encryption System}
\label{subsec:AE}
Our AE scheme consists of a quadruple of algorithms $(\gen, \KX, \enc, \dec)$ with specifications
\begin{itemize}
    \item $\gen(1^{\lambda}) \to (\kx^P, \kx^S)$,
    \item $\KX(\kx_A^P, \kx_B^S) \to \sk_{AB},$
    \item $\enc(\sk_{AB}, m) \to ct,$
    \item $\dec(\sk_{BA}, \ct) \to m.$
\end{itemize}
We require this scheme to be correct, secure, and unforgable. These properties are precisely defined below. Correctness is standard, but security and authentication definitions seem to be non-standard.
\begin{definition}
\label{defn:AE-correctness}
Let
\begin{enumerate}
    \item $(\kx^P_A, \kx_A^S), (\kx^P_B, \kx_B^S)  \leftarrow \gen(1^{\lambda}).$
    \item $\sk_{AB} \leftarrow \KX(\kx_A^P,\kx_B^S), \sk_{BA} \leftarrow \KX(\kx_B^P, \kx_A^S).$
\end{enumerate}
We say our AE scheme is \textbf{correct} if with probability 1, we have $\sk_{AB} = \sk_{BA}$, and for any plaintext $m$ of length $L_{\ae}$, we have
$$\dec(\sk_{BA}, \enc(\sk_{AB}, m)) = m.$$
\end{definition}
\textbf{Remark}: In our implementation, we take $L_{\ae} = 1 \mathsf{KB}$.
\begin{definition}
\label{defn:AE-eval-oracle}
Given a key exchange secret key $\kx^S$, and a polynomial time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$, the \textbf{Eval oracle} $\Eval_{f}(\kx^S, \cdot)$ takes as input a "public key" $k$, a set of ciphertexts $\arg_{\ct} = \{\ct_i\}$, and a plaintext argument $\arg_{p}$. It computes 
$$\sk \leftarrow \KX(k, \kx^S)$$
$$m_i \leftarrow \dec(\sk, \ct_i).$$ 
It outputs $\enc(\sk, f(\{m_i\}, \arg_p))$.
\end{definition}
\textbf{Remark}: Note we require $f$'s output to be constant length. The $\Eval$ oracle is stronger than the $\KXE$, but weaker than the $\KXD$ oracle described in \cref{sec:IND-CCPKA}.
\begin{definition}
\label{defn:AE-eval-security}
Let $N, R$ be polynomial in $\lambda$. Consider the two experiments defined in \cref{expr:AE-real-ideal-world}.

\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $\cA$ stores $1^{\lambda}, r, \{\kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, \ct, \arg_p \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}().$
        \item $\ct^{0}_r \leftarrow \Eval_f(\kx_i^S, \kx_j^P, \ct, \arg_p)$.
        \item $\cA$ stores $\ct^{0}_r$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $\cA$ stores $1^{\lambda}, r, \{\kx_i^P\}_{i \in [N]}$.
    \item For $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i, j, m \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}()$.
        \item $ct^1_r \leftarrow \Sim(1^{\lambda}, \{(\kx_i^P, \kx_i^S)\}_{i \in [N]})$.
        \item $\cA$ stores $\ct^{1}_r$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\caption{Real and Ideal World Experiment for AE Scheme}
\label{expr:AE-real-ideal-world}
\end{figure}

Then we say the AE scheme is \textbf{Eval-Secure} if there exists a p.p.t simulator $\Sim$ such that for any polynomial-time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$ and any p.p.t adversary with oracle $\cA^O$, the real world experiment and the ideal world experiment are computationally indistinguishable.
\end{definition}
If we use symmetric key encryption with pre-distributed secret keys (as in \cite{angel2016unobservable}), then Eval-Security is implied by IK-CCA \cite[Definition 1]{BBDP01keyprivate}. Since we do not have pre-distributed secret keys, we need to show that the key exchange step is secure as well. In \cref{sec:IND-CCPKA}, we define a new security requirement called IND-CCPKA  and show that Eval-Security is a corollary of IND-CCPKA security. We believe most existing AEAD system should be IND-CCPKA secure, though we are unable to rigorously demonstrate this.\todo{Well... Can we?}

\begin{definition}
\label{defn:AE-unforgability}
Consider the forging experiment described in \cref{expr:AE-forging}.

\begin{figure}[h!]
\begin{framed}
\textbf{Forging Experiment}
\begin{enumerate}
    \item For $i$ from $1$ to $N$, $(\kx_i^P, \kx_i^S) \leftarrow \gen(1^{\lambda}).$
    \item $i, j, \ct \leftarrow \cA^{\Eval_f(\{\kx_i^S\}, \cdot)}(1^{\lambda}, \{\kx_i^P\}).$
\end{enumerate}
\end{framed}
\caption{Forging Experiment for AE Scheme}
\label{expr:AE-forging}
\end{figure}

Let $\ct_{\query, ij}$ be the set of output from queries to the Eval oracle of the form $\Eval_f(\kx_i^S, \kx_j^P, \cdot)$ or $\Eval_f(\kx_j^S, \kx_i^P, \cdot)$.

We say the AE scheme is \textbf{Eval-Unforgable} if there exists a p.p.t simulator $\Sim$ such that for any polynomial-time computable function $f: \Sigma^* \times \Sigma^* \to \Sigma^{L_{\ae}}$ and any p.p.t adversary with oracle $\cA^O$, we have
$$\PP(\dec(\KX(\kx_i^S, \kx_j^P), \ct) \neq \bot \land m \notin \ct_{\query, ij}) = \negl(\lambda).$$
\end{definition}
\todo{Does there exist problem with this definition? I'm fairly certain this gives what we want, but not 100\% sure this is actually correct.}

\textbf{Remark}: A corollary of Eval-Unforgability is the property that if $\{\kx_i^{P}, \kx_i^{S}\}(i = 1,2,3)$ are three randomly generated keypairs, and $\sk_{ij} = \KX(\kx_i^P, \kx_j^S)$, then for any message $m$, 
$$\Dec(\sk_{12}, \Enc(\sk_{13}, m)) = \bot$$ 
with probability $1 - \negl(\lambda)$. This property will be used in the correctness proof.
\subsubsection{PIR Scheme}
\label{subsec:PIR}
Central to our application is the Private Information Retrieval(PIR) scheme. It consists of three efficient algorithms
\begin{itemize}
    \item $\query(1^{\lambda}, i) \to (\ct, \sk)$.
    \item $\answer^{\DB}(1^{\lambda}, \ct) \to a$.
    \item $\dec(1^{\lambda}, \sk, a) \to x_i$.
\end{itemize}
% \arvid{Another PIR syntax, which I believe might be more standard?}
% \begin{itemize}
%     \item $\query_n(1^{\lambda}, i) \to (q, \mathsf{st})$.
%     \item $\answer_n(1^{\lambda}, D, q) \to a$.
%     \item $\dec_n(1^{\lambda}, \mathsf{st}, a) \to d$.
% \end{itemize}
% Nevermind! We are recycling the secret key for the PIR queries, because generating the keys is computationally expensive, and it does not affect security (it just becomes slightly less clean)
where $\DB$ is a length $N$ database with int64 entries, and $N$ is a parameter bounded by some polynomial $N(\lambda)$. It should satisfy the following standard correctness and security definitions \cite{kushilevitz1997replication}.
\begin{definition}
\label{defn:PIR-correctness}
For any database $\DB$ of length $N$ with entries of length $L_{\pir}$, consider the experiment
\begin{enumerate}
    \item $(\ct, \sk) \leftarrow \query(1^{\lambda}, i)$.
    \item $a \leftarrow \answer^{\DB}(1^{\lambda}, \ct)$.
    \item $x_i \leftarrow \dec(1^{\lambda}, \sk, a)$.
\end{enumerate}
We say the PIR scheme is \textbf{correct} if $x_i = DB[i]$ with probability $1$.
\end{definition}
\begin{definition}
\label{defn:PIR-SIM-security}
Let $n, R$ be polynomially bounded in $\lambda$. Consider the experiments in \cref{expr:pir-real-ideal-world}. We say the PIR scheme is \textbf{SIM-Secure} if there exists a p.p.t simulator $\Sim$ such that for any stated p.p.t adversary $\cA$, the view of $\cA$ under the real world experiment and the ideal world experiment are computationally indistinguishable. 

\begin{figure}[h!]
\begin{framed}
\textbf{Real World Experiment}
\begin{enumerate}
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i_r \leftarrow \cA(1^{\lambda}, n)$.
        \item $\ct_r^0, \sk \leftarrow \query(1^{\lambda}, i_r)$.
        \item $\cA$ stores $\ct_r^0$.
    \end{enumerate}
\end{enumerate}
\textbf{Ideal World Experiment}
\begin{enumerate}
    \item for $r$ from $1$ to $R$
    \begin{enumerate}
        \item $i_r \leftarrow \cA(1^{\lambda}, n)$.
        \item $\ct_r^1, \sk \leftarrow \Sim(1^{\lambda}, n)$.
        \item $\cA$ stores $\ct_r^1$.
    \end{enumerate}
\end{enumerate}
\end{framed}
\caption{Real and Ideal World Experiment for PIR Scheme}
\label{expr:pir-real-ideal-world}
\end{figure}
\end{definition}
For our implementation, we use libsodium's key exchange functionality as the $\gen$ and $\KX$ functions, and libsodium's secret key AEAD for the $\enc$ and $\dec$ functions \cite{libsodium}. We conjecture that this AE scheme satisfies IND-CCPKA security as in \cref{defn:AE-CCPKA}, thus satisfies \cref{defn:AE-eval-security}. We use Addra's FastPIR as the PIR protocol. The definition, correctness, and security proof of FastPIR can be found in \cite[Section 4]{ahmad2021addra} and in more detail \cite{angel2018thesis}.

Throughout the rest of the document, we denote the AE scheme $\Pi_{\ae}$, and the PIR scheme $\Pi_{\pir}$.
\subsection{Messages, Sequence numbers, ACKs}
\label{subsec:ACK}
Our integrity definition \cref{defn:messaging-integrity} requires protection against replay attacks. In this section, we describe how our system adopts TCP's Acknowledgement system to offer such protection.

Each client $i$ labels all messages to be sent to another client $j$ with a sequence number. In the order client $i$ receives $\send$ inputs to client $j$, client $i$ label the messages with sequence number $1,2,\cdots$. The client will transmit the labeled message\footnote{Called chunk in the implementation.} $\msg^{lb} = (k, \msg)$, where $k$ is the sequence number and $\msg$ is the actual message. 

Critical to both consistent prefix and eventual consistency is the ACK messages. An ACK message is a special type of messages denoted $\ACK(k)$, encoding a single integer $k$.\footnote{In our implementation, the ACK message is slightly more complicated to take chunking into account.}. When client $j$ sends $\ACK(k)$ to client $i$, it means ``I have read all messages up to message $k$ from you". As we will soon define rigorously, user $i$ will keep broadcasting message $k$ until user $j$ sends $\ACK(k)$, in which case they begin broadcasting message $k + 1$. 

To prevent replay attack, we ensure any ACK message is distinct from any labeled messages generated from user input.\footnote{In our implementation, ACKs and Chunks use different protobuf structs to guarantee this.}

We finish by detailing a subtlety on the length of messages. Let $L_{\msglb}$ denote the length of a labeled message $\msg^lb$, and let $L_{\ct}$ be the length of a ciphertext generated by encoding $\msg^{lb}$ with $\Pi_{\ae}.\enc$. While the input messages have length $L_{\msg}$, the messages client sent to the server have length $L_{\ct}$. We set parameter $L_{\ae} = L_{\msglb}$ in the AE scheme, and $L_{\pir} = L_{\ct}$ in the PIR scheme.
\subsection{The Anysphere Core Protocol}
\todo{I'm going to stick to our actual implementation as closely as possible, please point out anything that doesn't agree with the current protocol, greatly appreciate it.}

We first recall some notations.
\begin{itemize}
    \item $\lambda$ is the security parameter.
    \item $N$ is the number of users.
    \item $T$ is the number of timesteps our protocol is run.
    \item $L_{\msg}$ is the length of the raw message.
    \item $\Pi_{\ae}$ is an AE scheme satisfying \cref{defn:AE-correctness}, \cref{defn:AE-eval-security} and \cref{defn:AE-unforgability}.
    \item $\Pi_{\pir}$ is a PIR scheme satisfying \cref{defn:PIR-correctness} and \cref{defn:PIR-SIM-security}.
\end{itemize}
We can now formally define Anysphere's core protocol.
\begin{definition}
\label{defn:asphr-code}
The Anysphere messaging system $\Pi_{\asphr}$ implements the methods of \cref{defn:messaging-scheme} following the pseudocode below. In each method, the caller stores all inputs for future use.
\vspace{10pt}

$\mathbf{\Pi_{\asphr}.C.\mathsf{Register}}(1^{\lambda}, i, N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item Initialize empty map $\frienddb$. The map take registration info as keys, and the following fields as values.    \footnote{These fields are currently implicit. They are made explicit here for simplicity}
    \begin{itemize}
        \item $\mathsf{sk}$, the secret key.
        \item $\seqs$, the sequence number of the current message being broadcasted to the friend.
        \item $\seqe$, the highest sequence number ever assigned to messages to the friend.
        \item $\seqr$, the highest sequence number received from the friends.
    \end{itemize}

    \arvid{a bit confused between seqend and seqstart...}
    \stzh{in other words, the inbox contains messages in [seqstart, seqend].}
    \item Initialize empty maps $\inb, \outb$. The maps take registration info as keys, and arrays of messages as values.\footnote{They are named Friend, Inbox, Outbox in our code. Our code is slightly more complicated to support features like sending to multiple friends and chunking.}
    \item Set a transmission schedule $T_{\trans}$. The user can customize this parameter. We assume $T_{\trans}$ is upper bounded by a constant $T_{\trans}^U$.
    \item $(\kx^P, \kx^S) \leftarrow \Pi_{\ae}.\gen(1^{\lambda})$. 
    \item Return $\reg = (i, \kx^P)$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\mathsf{InitServer}}(1^{\lambda}, N)$.
\vspace{5pt}
\hrule
\vspace{5pt}
Initialize arrays $\msgdb, \ackdb$ of length $N$ with entries of length $L_{\ct}$. Fill them with random strings.

\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\Userinput}(t, \cI)$
\vspace{5pt}
\hrule
\vspace{5pt}
This method runs in two phases. Phase 1 handles the user input $\cI$, and phase 2 formulates the server request.

Phase 1: 

If $\cI = \emptyset$, do nothing. 

If $\cI = \send(\reg, \msg)$, 

\begin{enumerate}
    \item Check that $\reg$ is in $\frienddb$. If not, skip to Phase 2.
    \item If $\reg$ is the registration of $C_i$ itself, append $\msg$ to $\inb[\reg]$, and skip to Phase 2. \footnote{Skipping this step breaks consistent prefix.}
    \item Add $1$ to $\frienddb[\reg].\seqe$. 
    \item Push $\msg^{lb} = (\frienddb[\reg].\seqe, \msg)$ to $\outb[\reg]$.
\end{enumerate}

If $\cI = \trust(\reg)$.
\begin{enumerate}
    \item Check if $\reg$ is in $\frienddb$. If so, skip to Phase 2.
    \item $(i, \kx_f^P) \leftarrow \reg$.
    \item $sk \leftarrow \Pi_{\ae}.\KX(\kx_f^P, \kx^S).$
    \item $\frienddb[\reg] \leftarrow \{\sk: sk,  \seqs: 1, \seqe: 0, \seqr: 0\}$.
\end{enumerate}

Phase 2:
\begin{enumerate}
    \item If $t$ is not divisible by $T_{\trans}$, return $\emptyset$.
    \item Let $\{\reg_1, \cdots, \reg_k\}$ be the keys of $\frienddb$, with $k\leq B$. Construct $S = [\reg_1,\cdots, \reg_k, \reg, \cdots, \reg]$, where we add $B - k$ copies of $\reg$, a dummy registration info with $\reg[0] = 0$ and $\reg[1]$ a randomly generated public key. Sample $\reg_s, \reg_r$ uniformly and independently at random from $S$. \arvid{this is not what we currently do. maybe we should. we should make a decision on the CF attack here and what is acceptable. i think my favorite idea is leaking a rounded version of the number of friends, or something like that. however, the way the code works now where we pick a random friend among the friends that we have outgoing messages to is quite nice because it means that messages will get delivered much faster (especially once we implement PIR batch retrieval)...}
    \item Let $\msg$ be the (labeled) message with sequence number $\frienddb[\reg_s].\seqs$ in $\outb[\reg_s]$. If $\outb[\reg_s]$ is empty, let $\msg \leftarrow (-1, 0^{L_{\msg}})$.
    \item $\sk \leftarrow \frienddb[\reg_s].\sk$. If $\reg_s$ does not exist in $\frienddb$, randomly generate a secret key $\_, \sk \leftarrow \Pi_{\ae}.\gen(1^{\lambda}).$
    \item $\seqr \leftarrow \frienddb[\reg_s].\seqr$.
    \item Encrypt Messages with $\sk$.
    \begin{itemize}
        \item $\ct_{\msg} \leftarrow \Pi_{\ae}.\enc(\sk, \msg).$
        \item $\ct_{\ack} \leftarrow \Pi_{\ae}.\enc(\sk, \ACK(\seqr))$. \arvid{should we talk about the ACK db here, and the fact that we always send all ACKs to everyone? maybe we shouldn't do that anymore... it was necessary for prioritization, but if we don't want to do prioritization then maybe we shouldn't do it anymore}
    \end{itemize}
    \item Let $\reg_r = (i_r, \_)$. Formulate a PIR request for index $i_r$. %\arvid{this $r$ is not the same as the $r$ in $\reg_r$? maybe this should be $i_r$ or something}
    \begin{itemize}
        \item $\ct_{\query}, \sk_{\pir} \leftarrow \Pi_{\pir}.\query(1^{\lambda}, i_r).$
    \end{itemize}
    \item return $\req = (\ct_{\msg}, \ct_{\ack}, \ct_{\query})$.
    \item Remember $\reg_r$ and $\sk_{\pir}$.
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.S.\Clientrpc}(t, \{\req_i\}_{i = 1}^N)$
\vspace{5pt}
\hrule
\vspace{5pt}
\item for $i$ from $1$ to $N$
\arvid{do we want to deal with authentication tokens here? only if we modify the security definition to include potentially malicious clients, which I'm not sure is worth the trouble...}
\stzh{I vote for no Authentication token for now.}
\begin{enumerate}
    \item If $\req_i = \emptyset$, let $\resp_i = \emptyset$, and continue to next $i$. 
    \item Parse $\req_i = (\ct_{\msg}, \ct_{\ack}, \pk_{\pir}, \ct_{\query})$.
    \item $\msgdb[i] \leftarrow \ct_{\msg}, \ackdb[i] \leftarrow \ct_{\ack}$.
    \item $a_{\msg} \leftarrow \Pi_{\pir}.\answer^{\msgdb}(1^{\lambda}, \ct_{\query}).$
    \item $a_{\ack} \leftarrow \Pi_{\pir}.\answer^{\ackdb}(1^{\lambda}, \ct_{\query}).$
    \item $\resp_i \leftarrow (a_{\msg}, a_{\ack}).$
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\Serverrpc}(t, \resp)$
\vspace{5pt}
\hrule
\vspace{5pt}
\begin{enumerate}
    \item If $\resp = \emptyset$, return.
    \item Parse $\resp = (a_{\msg}, a_{\ack})$. Let $\reg_r, \sk_{\pir}$ be defined in the last call to $\Pi_{\asphr}.C.\Userinput$.
    \item $\ct_{\msg} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\msg}).$
    \item $\ct_{\ack} \leftarrow \Pi_{\pir}.\Dec(1^{\lambda}, \sk_{\pir}, a_{\ack}).$
    \item $\sk_{\ae} \leftarrow \frienddb[\reg_r].\sk$.
    \item Decipher the message.
    \begin{enumerate}
        \item $\msg^{lb} \leftarrow \Pi_{\ae}.\Dec(\sk_{\ae}, \ct_{\msg})$.
        \item If $\msg^{lb} = \bot$ or $\msg^{lb}[0]$ is not $\frienddb[\reg_r].\seqr + 1$, skip the next two steps.
        \item Add $1$ to $\frienddb[\reg_r].\seqr$. 
        \item Let $\msg$ be $\msg^{lb}[1]$. Push $\msg$ to $\inb[\reg_r]$.
    \end{enumerate}
    \item Decipher the ACK.
    \begin{enumerate}
        \item $\ack \leftarrow \Pi_{\ae}.\Dec(1^{\lambda}, \sk_{\ae}, \ct_{\ack})$.
        \item If $\ack = \bot$ or $\ack$ is not the form $\ACK(k)$ for some $k$, return.
        \item Let $\ack = \ACK(k)$. If $k < \frienddb[\reg_r].\seqs$, return.
        \item $\frienddb[\reg_r].\seqs \leftarrow k + 1$. Remove the message with sequence number $k$ from $\outb[\reg_r]$.
    \end{enumerate}
\end{enumerate}
\vspace{10pt}
$\mathbf{\Pi_{\asphr}.C.\mathsf{GetView}}()$
\vspace{5pt}
\hrule
\vspace{5pt}
Let $\cF$ be the set of keys in $\frienddb$. Let $\cM$ be the set $\{(\reg_r, \msg): \msg \in \inb[\reg_r]\}$. Return $(\cF, \cM)$.

\end{definition}